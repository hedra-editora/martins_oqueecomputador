#Passeio pelos computadores 

Os computadores têm uma característica própria bem interessante:
invadem a vida das pessoas, invadem todas as nossas atividades e
profissões, invadem empresas e governos, mas contrariamente, não se
deixam devassar com facilidade. Os computadores estão entre nós, mas
permanecem, para muitos, envoltos numa barreira de complexidade.
Isso parece reservá-los apenas ao conhecimento de uns poucos que
buscam — por motivos diversos — uma “compreensão técnica” dos
computadores. Uma busca nem sempre trivial.

*O que é computador* descreve, tal como um guia, uma viagem ao mundo
dos computadores pelo caminho mais curto e mais simples. Nesse
sentido, representa um esforço para vencer a complexidade dos
computadores (sem cair no simplismo), de modo a domar essa
complexidade e torná-los acessíveis a um público mais amplo de
estudantes, gestores diversos, homens de negócios, políticos e
profissionais ou apenas “curiosos”. O desafio é desenvolver ideias,
conteúdos e os avanços na área, da forma mais acurada possível e, ao
mesmo tempo, leve e estimulante. Só assim pessoas “que não são do
ramo” terão a oportunidade não só de se alfabetizar em computadores
(seus tipos, funcionamento, aplicações e papéis em uma *sociedade
baseada em conhecimentos*) mas, sobretudo, de se iniciarem na
“compreensão do uso” e do alcance dos computadores, inclusive a
compreensão do novo cenário mundial dos computadores, nesta virada de
século. Este é, portanto, um livro de “exorcismo”. Um livro sobre
como “exorcizar” o medo de uma tecnologia que está a estender o nosso
cérebro (rumo a uma inteligência coletiva; rumo à *noosfera* de
Teilhard de Chardin) e o nosso próprio ser — quando já se trabalha até
mesmo para uma *vida artificial* e uma *inteligência artificial*.

O texto oferece uma visão abrangente dos computadores suficiente,
por exemplo, para adequadamente incluir (na última seção) uma
contextualização da participação do Brasil na copa paralela de
*inteligência maquinal* — a *Robocup* — ocorrida durante a última
copa de futebol (Alemanha, 2006). Abrangência essa que também pode
enriquecer pessoas já engajadas em profissões informáticas. É o caso
de operadores, digitadores, preparadores de dados, ecologistas da
informática (analistas de impactos e articuladores de sistemas),
engenheiros de software, engenheiros do conhecimento, analistas de
sistemas e programadores amadores e profissionais que, embora
restritos a suas respectivas funções, também precisam ampliar
horizontes em relação aos modernos conceitos e às novas temáticas
computacionais em discussão, pelo mundo afora.

Na organização dos assuntos foi adotada a metodologia modular, isto
é, cada aspecto relevante dos computadores foi explorado em seções
independentes, formando, ao final, um conjunto. Assim o leitor poderá
trabalhar cada seção, sem atrelar uma à outra, na ordem que melhor lhe
convier.

# Computadores em essência

## Computador, popularmente falando

Entre os entusiastas da informática, é comum falar do computador como
uma “maravilhosa máquina burra”. Embora sem erros conceituais, essa é
uma ideia mais poética que científica. A expressão *maravilhosa
máquina* ressalta a capacidade que têm os computadores de realizar
fantásticas operações, enquanto o adjetivo *burra* enfatiza a
necessidade da inteligência humana por trás dessas incríveis
operações, pelo menos
nos estágios iniciais dos processos inteligentes. Ou seja, sem a
intervenção e a ação criadora do homem, não haveria a menor chance de
o computador vir a adquirir níveis de inteligência.

Há também, os que pensam ser o computador a mesma coisa que
Informática. A confusão, nesse caso, é gritante. Corresponde a não
diferenciar a Medicina do bisturi ou a Astronomia do telescópio. A
informática é a teoria ou a ciência que trata de tudo que se relaciona
com o processamento automático da informação. É este, aliás, o sentido
etimológico do termo informática. Um feliz termo, nascido da expressão
francesa (*infor*)*mation* + *auto*(*matique*) (“informatique”) e
equivalente ao termo inglês *Computing* (Computação, Ciência da
Computação), criado pelos países de fala inglesa, justamente para
rejeitarem o nome Informática em substituição ao antigo nome da
disciplina que os norte-americanos chamavam *Processamento de Dados*
(“Data Processing”, 1959). Ou seja, a expressão norte-americana
“Processamento de dados” não pegava bem para concorrer com a elegância
do termo Informática, adotado pela Europa — exceto o Reino Unido. Duas
lições até aqui. Primeira: o computador é o
objeto de estudo e apenas um instrumento sofisticado a serviço desta
Informática ou Computação. Segunda: “processamento de dados” vale
apenas como uma sequência de operações sobre dados, mas não vale
mais como designação da ciência informática. Fuja — como o “diabo
foge da cruz” — de tudo que ainda hoje estão lhe vendendo com tal
denominação, pois estão querendo lhe trazer de volta à idade da
pedra dos computadores (os anos 1950).

Uma terceira concepção de computador é encontrável até mesmo entre
membros da comunidade científica: a de que o computador é uma “máquina
que computa”. Ora, tal simplificação nada acrescenta ao conhecimento
dos iniciantes sobre o computador, além de conter impropriedades.
Uma simples calculadora de mesa, por exemplo, também computa e nem
por isso é um computador. Definir o computador dessa maneira é reduzir
seu universo de aplicações. É aprisioná-lo em sua função mais
trivial: realizar cálculos.

A indagação é: como apresentar uma ideia científica de computador,
capaz de sintetizar seus elementos e funções fundamentais? Que
características essenciais distinguem,
por exemplo, o computador de uma simples maquininha de calcular? Vamos
tentar uma resposta por partes, inicialmente com um conceito ainda
aproximativo ou temporário de computador que será, oportunamente,
retomado e enriquecido. Antes, porém, analisemos o sentido dos termos dado e informação (deixando para depois o termo conhecimento).
Eles são a base para numerosos conceitos informáticos, inclusive para
o conceito de computador.

## Dado é diferente de informação

Informação é um artigo que quase sempre tem valor e é ela a
matéria-prima do conhecimento. Sem boa informação capaz de gerar
conhecimentos aplicáveis, é muito difícil, senão impossível, tomar
decisões inteligentes. Os modernos computadores são capazes de aceitar
grande massa de dados brutos e, daí, produzir informações que permitem
tomar decisões em praticamente todas as áreas da vida moderna. Nisso
reside, aliás, o poder dos computadores. É claro que a informação só
tem valor para os que dela saibam tirar proveito, saibam usá-la para a
criação de conhecimentos ou aprender por meio dela. Exemplifiquemos.

>*Dado:* um grande navio de carga foi avistado perto do Porto de
Santos, às 6 horas da tarde.

Para o frequentador de praia habitual, que apenas localizou o grande
navio no horizonte, o fato significou simplesmente um elemento
adicional no pôr-do-sol daquela tarde. Nada mais. No momento, porém,
que o fato é comunicado a outra pessoa, digamos o guarda-costeiro/
portuário, este sim pode usar seus próprios conhecimentos náuticos
para agora interpretar a comunicação feita pelo banhista.

>*Informação*: a forma do navio, seu tamanho, características e
velocidade coincidem com a descrição do cargueiro brasileiro *Netuno*,
que se encontrava retido no Porto de Nova York, por falta de
pagamento das taxas portuárias.

Essa foi a conclusão do guarda-costeiro que processou o dado
(mentalmente apenas), transformando-o em
informação sobre o cargueiro brasileiro, e poderá conferir essa
informação com a companhia de navegação competente.

Outro exemplo: considere agora que tenha chegado à sua mesa de
trabalho, isoladamente, o dado 2021540, escrito em uma folha de papel.
O que representa? Por si só, não tem qualquer sentido, até que alguém
lhe atribua um significado — “informe-o” — dizendo tratar-se, por
exemplo, do resultado da multiplicação do número Y pelo número Z ou,
talvez, dizendo tratar-se de algum número de telefone. Diferenciamos
então, dizendo:

>*Dado* é tudo que é preparado para entrar no computador e ser por ele
processado. Em outras palavras, é tudo que é previamente codificado
para ser aceito como entrada (*input*) e trabalhado pelo computador.
Dados podem ser usados como itens individuais ou trabalhados como
coleções de itens. Assim, os dados de um cheque (número, emitente,
valor etc.) ou os dados de um documento de identidade podem ser
considerados como exemplos de coleções (ou registros) de dados em
condições de alimentar um computador.

*Informação*, por outro lado, é a saída (*output*) resultante de um
processamento (mental ou computacional). Também se diz que informação
é um dado ao qual, ao ser processado, é atribuído um sentido ou
interpretação. Ou seja,

>*Informação* = *Dado* + *Interpretação*

Assim, no exemplo anterior do dado 2021540, ele se transforma em uma
informação, com sentido próprio. À medida que algum sistema (ou
alguém), por via de interpretação, atribui significado a esse dado —
ou “informa-o” — aquilo que era apenas a sequência de dígitos 2021540 se transforma
em informação. É importante ter em mente, porém, que os computadores
ainda não são muito bons em fazer, autonomamente, tipos avançados de
interpretação. As pessoas ainda detêm este domínio sobre a interpretação de muitas coisas, sobre o interpretar daquilo que seja
visualizado, de interpretar textos, de interpretar fatos, ocorrências
e pré-ocorrências. Ou seja, o domínio sobre a interpretação do mundo.

## Computador, cientificamente falando

Os exemplos ilustrando as ideias de dado e informação permitem que
se tirem, pelo menos, três conclusões. Primeira: nenhum dado tem
sentido por ele mesmo. Segunda: toda informação nasce de um dado
quando este é processado. Terceira: processar um dado é atuar sobre
ele quer mentalmente (como fez o guarda-costeiro do exemplo), quer
manual, quer mecânica ou eletronicamente. Em nosso caso, estamos
interessados apenas no processamento eletrônico. Com base nessas
conclusões podemos, então, formular a seguinte ideia de computador:

>*Um computador é uma máquina digital e eletrônica de processamento
automático de dados.*

Vamos esclarecer cada termo desse enunciado, individualmente, a
começar por:

*Máquina*

O termo *máquina* foi introduzido para lembrar-nos que os computadores
não são artefatos misteriosos,
míticos. Como máquinas, estão na mesma linhagem de descendência das
locomotivas a vapor, dos moinhos de vento e das máquinas de costurar.
Máquinas podem funcionar bem ou mal e nenhuma é infalível, por mais
poderosa que seja. Computadores têm seu lado maquinal, mas não são
máquinas apenas. Computadores são, essencialmente, entes matemáticos
antes de vestirem a roupagem maquinal.

*Digital*

O adjetivo *digita*l significa que os computadores trabalham
mediante o armazenamento de dados (e informação) em forma de códigos
que representam as letras, os algarismos e os números. Sons,
desenhos e gráficos são também representados no interior do computador
em forma digital. O termo mesmo refere-se a *dígito* (*digitus* =
dedo, em latim), para indicar os elementos 1 e 0, formadores de
códigos.

*Eletrônica*

O adjetivo *eletrônica* indica que o computador é construído a
partir de componentes eletrônicos de estado sólido, conhecidos por
circuitos integrados ou, simplesmente, *chips*. Todas as ações
elétricas e magnéticas (que tornam possível
a representação interna de letras e números) são realizadas dentro
desses dispositivos construídos de materiais sólidos
— daí a referência feita a componentes de estado sólido.

*Processamento automático de dados*

E agora vem a expressão mais significativa na conceituação de
computador. A expressão (*data processing*) é bem ampla, como
globalização de subtarefas. Descreve quase toda a variedade de
trabalhos que os computadores podem realizar. Tudo o que se faz com
a ajuda do computador — da escrita de uma carta à aterrissagem de
uma nave espacial na Lua — ao final, se reduz a um processamento de
informação.

O processamento, assim, tem vários nomes. Dependendo da tarefa a ser
levada ao computador, processamento de dados pode consistir de uma
das seguintes tarefas ou mesmo de suas combinações:

- *Classificação de dados e informações* 
- *Seleção de dados e informações*
- *Reorganização de dados e informações* 
- *Realização de cálculos*
- *Manipulação de símbolos*

Note-se que deixamos de incluir, de propósito, aquela capacidade que
os computadores, hoje, têm de fazer raciocínios, ou seja, a
capacidade de tirar novas conclusões lógicas, com base em informações
já conhecidas por eles. Desenvolver essa capacidade (que preferimos
não incluir como, propriamente, de processamento de dados), inclusive, está sendo a missão dos chamados computadores inteligentes dos
quais trataremos mais à frente. Por outro lado, fazer cálculos (a
mastigação de números propriamente), ao contrário do que muita gente
pensa, é apenas um dos cinco aspectos da capacidade dos computadores
em sua função maior de processamento. Veremos outras funções em
seguida.

# Computadores em uma moderna concepção

## Coleção tripartite de recursos

Computador não é aquilo que você vê, fisicamente falando. Sobre os
computadores, alguém já brincou dizendo: “Hardware é a parte que
você chuta. Software é a parte que você xinga”. Trata-se de uma
brincadeira, é claro; mas uma brincadeira preocupada em separar, dividir e chamar de computador só aquilo que você vê, pega, liga, chuta.
Ou seja: a tentação de ver o hardware, os dispositivos, a máquina
como “o computador”.

Hoje, a mais avançada concepção não destaca o computador como
máquina, mas o trata como uma *coleção tripartite de recursos*,
igualmente importantes: I) a parte física, compreendida pelos
dispositivos (o hardware); II) a parte imaterial, compreendida pelo
*programa armazenado* (ou software); III) e a parte de *dados* que é a
matéria-prima dos processamentos computacionais, sem a qual nem
computador nem processamentos existem. Conjuntamente, esses três
componentes fazem parte dessa moderna definição de que falo. Sem a
parte física, construída de ferro, aço, cobre e outros materiais
sólidos (*chips* de silício, ou *microchips*), não existirá
computador, por um lado. Mas, também sem programas e sem dados a processar não existe computador; e a parte física não passará de um
montão de ferro. Assim, em uma formulação mais completa e avançada de
computador vamos dizer:

>Computador = *Dispositivos* + *Programas* + *Dados*

Ou seja:

>Computador é uma COLEÇÃO DE RECURSOS, incluindo dispositivos de
processamento eletrônico e digital, programas armazenados e conjunto
de dados, coleção esta que — sob o controle dos programas
armazenados — automaticamente aceita dados (dá entrada), processa, dá
saída, armazena e recupera dados (no sentido informático de trazer de
volta da memória), podendo ainda transmitir e receber dados de outros
computadores.

Resta agora dissecar os conteúdos aqui envolvidos.

## Programas = Software

Os três componentes de que falamos — programas ou software,
dispositivos e dados — foram todos incluídos na sintetização da ideia
de computador. E não só isso. As sete funções primitivas do computador
também o foram. Nessa coleção de recursos, o programa (o software, na
terminologia internacional da Engenharia de Software, ramo da Informática) é uma série de instruções compatíveis preparadas pelo
programador. Essas instruções, uma vez armazenadas
(daí a expressão *programa armazenado*), governam o hardware,
levando-o a cumprir todas as suas funções. Elas são escritas em alguma
linguagem entendível pelo hardware e são essas instruções de um
programa armazenado que, de fato, diferenciam um computador de uma
simples calculadora de mesa.

## Algoritmo

As instruções de um programa não podem ser escritas de forma
desconexa, aleatória. Um programa não é um amontoado de instruções.
Elas são escritas segundo uma lógica. Cada tarefa a ser executada pelo
computador exige uma lógica de solução ou método, também chamado de
*algoritmo*, que determina a ordem em que as instruções devem ser
escritas. Daí, é só levá-las aos dispositivos (computador, por
simplificação) para testes e execução. Descobrir um algoritmo ou
método para cada tarefa é, pois, o primeiro desafio para o
programador. Um bom exemplo de algoritmo é uma receita de bolo, cujos
ingredientes, passos a serem dados e momentos de suas combinações têm
de ser seguidos com rigor, sob pena de se produzir
outro bolo, e não aquele que se tinha em mente antes do processo
começar. Assim também é um programa: uma receita rigorosa descrita
mediante frases (instruções) em dada linguagem escolhida.

## Sete funções permanentes

Guiado pelas instruções de um programa previamente armazenado (o
Sistema Operacional), o computador pode então executar suas sete
funções primitivas, por nós já incluídas no próprio conceito anterior
de computador. Estamos falando de funções primitivas. Muitas outras funções decorrentes da conexão com a internet, por exemplo,
poderiam ser mencionadas. Mas vamos considerar aqui apenas essas
ditas primitivas que são:

### Função de aceitação de dados:

O computador dá entrada aos dados a serem trabalhados pelo programa,
recebendo seus *input* vindos de seu ambiente externo.

### Função de armazenagem de dados**:

Consiste em gravar ou armazenar dados úteis durante e depois da
operação do computador.

### Função de recuperação ou resgate de dados**:

Obtém de volta para o ambiente externo do sistema tudo que tenha sido
prévia e internamente armazenado. Recuperar ou resgatar significa
trazer algo de volta para o usuário.

### Função de processamento de dados**:

Compreende a classificação, seleção, reorganização de dados,
realização de cálculos de todos os tipos e a manipulação de
símbolos.

### Função de saída de dados**:

É a visualização, pelo visor do computador, do painel de controle
(*console*), da impressora ou de algum outro dispositivo de saída, de
tudo que foi processado.

### Função de remessa ou transmissão de dados**:

Mediante esta função, o computador pode transmitir dados para outro
computador porventura conectado.

###Função de recebimento de dados**:

Faz um computador receber dados enviados por outro computador.

## Dispositivo = Hardware

A execução de cada função, no entanto, além de depender de um
programa, está associada aos vários dispositivos eletrônicos que
formam a estrutura física dos computadores. Três são os tipos básicos
de dispositivos: I) Memória interna; II) Dispositivos de entrada e
de saída de dados; e III) Processador. O que faz cada um deles?

## Memória

Tudo que entra para o computador fica primeiro armazenado em sua
memória interna. Constituída de circuitos integrados (*chips*) e
residindo assim no interior do computador, a memória tem o papel de
manter dados, programas e resultados de processamentos enquanto perdurar a passagem de uma corrente elétrica. Cessada a corrente, tudo
se apaga da memória.

## Dispositivos de entrada/saída de dados
--------------------------------------

São também chamados de *periféricos*. Carregam dados e programas até a
memória interna e desta, de volta, ao usuário. *Periféricos de entrada
de dados* são o teclado do computador e a leitora de cartão da loteria
federal. A impressora e o visor do computador são *periféricos de
saída de dados*.

## Processador

É o cérebro do computador, daí o apelido de “cérebro eletrônico” que
os computadores já tiveram (na década de 1950). No momento exato do
processamento (e há um relógio para isso), o processador transporta
para um de seus compartimentos (*a unidade aritmética e lógica*) cada
instrução que estiver aguardando na memória. Esse transporte é
ordenado pela unidade de controle de instruções, também pertencente ao
processador. Após ser interpretada, cada instrução é executada. O
resultado final do processamento ou da execução de um programa volta
então para a memória e daí para o usuário.

# Computadores dedicados x computadores multiuso

## Uso geral e uso especializado

Para que serve, então, esta coleção de recursos que inclui
dispositivos, programas e dados? Ideia errônea comumente difundida
sobre os computadores é a de que todos eles, indistintamente, podem
fazer tudo, ou quase tudo, pelo fato mesmo de serem computadores. Ou
seja, poucos se dão conta de que os computadores não são artefatos
uniformes na ação e padronizados em suas capacidades,
mas estão agrupados em classes, de acordo com critérios bem definidos.
Nem todos podem, nem todos fazem quase tudo, mas operam segundo suas
categorias. Há vários critérios para o arranjo dos computadores em
tipos ou classes. O aspecto da geração, isto é, da tecnologia da
época de fabricação, é um deles. Daí falar-se em computadores de
primeira, segunda, terceira, quarta e até de quinta geração. Também um
computador pode ser fabricado para certo uso específico, em lugar de
seu uso em múltiplas áreas e atividades. Este, aliás, constitui outro
critério para classificar computadores. Certa vez, um colega meu
dirigia o Laboratório de Solos da UFPI (o professor Cordeiro) e me
convidava a seu laboratório para conhecer avançados equipamentos
que a universidade acabara de receber como doação de outra
universidade norte-americana. O professor me consultava sobre a
existência de possibilidade de empregar o computador, acompanhante
desses equipamentos doados, para efeito de tarefas outras que não
fossem aquelas específicas das análises físico-químicas de solos. O
professor estava diante de um caso de *computador dedicado*, e não
sabia que ele funcionava como uma caixa preta. Computadores fabricados
para certo uso restrito, ou bem limitado grupo
de tarefas, são chamados *computadores dedicados*. Opõem-se aos
*computadores multiuso* ou de múltiplas aplicações, capazes de
processar dados nas mais diversas áreas de atividades.

## “Computadores de bordo” em automóveis e aeronaves

Exemplos interessantes de computadores dedicados, porém ainda não
muito populares entre nós, são os “*computadores de bordo*” e os
“*computadores alfabetizadores*”.

Carros de corrida, aeronaves e mesmo carros de passeio já trazem
embutidos “computadores de bordo”, altamente miniaturizados, para o
controle e a monitoração de funções e equipamentos.

A segurança absoluta desses meios de transporte exige que, à medida
que aumenta a velocidade de corrida ou de voo, as decisões de controle
do motor e de outros subsistemas devem ser tomadas muito mais
rapidamente. Para as multinacionais da indústria automobilística,
evidentemente lá nos países centrais, o desafio tecnológico agora é
construir carros computadorizados, com sistemas cada vez mais
capazes de assessorar
motoristas e pilotos na monitoração de processos e funções como
injeção do combustível, controle de emissão, sensor de oxigênio, tempo
do motor, regulação do gerador, carregamento de bateria etc.
Automóveis equipados com computadores de bordo, além de indicarem a
quantidade de combustível no tanque, ainda calculam a distância a
percorrer antes de ser começada a viagem. Indicam a posição geográfica
do carro, falam com o motorista e orientam-no (via mapa) sobre como
chegar ao destino desejado. Também têm acesso à Internet ativado por
voz, a informações sobre o trânsito em tempo real e capacidade de
diagnosticar defeitos de funcionamento, como nos garante Thomas A.
Stewart, em *A riqueza do conhecimento* (2002). Não apenas os carros
são capazes de diagnosticar os seus próprios defeitos durante uma
viagem como, automaticamente, fazem até o contato com os serviços de
emergência e atendimento a clientes em caso de acidentes.

Aeronaves, por outro lado, são as máquinas mais sofisticadas,
complexas e também mais seguras que a humanidade já logrou
construir, em virtude mesmo de estar envolvida a proteção da própria
vida de todos aqueles que, por razões diversas, têm de embarcar em
viagens nacionais, continentais e intercontinentais. Em aeronaves,
especificamente, condições físicas, por
exemplo, dentro e fora do avião (assim como a velocidade do ar) têm de
ser permanentemente detectadas, monitoradas antes mesmo que ocorram
variações bruscas (como aumento na velocidade do ar, por exemplo).
Tudo isso é possível por meio de computadores dedicados miniaturizados
que integram seus painéis de controle.

(imagem 34)

## “Computadores alfabetizadores”

Exemplo interessante de computador dedicado, já em operação na área
educativa da Inglaterra, é o “*My talking computer*”, como apoio ao
processo de alfabetização de crianças a partir de três anos e meio.
Computadores, como esse, já saem de fábrica devidamente programados,
com programas gravados na memória interna da máquina (um processo
chamado *firmware*). Em um país como o nosso, onde infelizmente o
analfabetismo ainda campeia solto, esses sim seriam aliados poderosos
em num contexto de esforço educacional para erradicação do
analfabetismo mais do que “computadores de bordo” para carros de luxo.

Convém, no entanto, não confundi-los com os microcomputadores de uso
geral, que porventura venham a ter aplicações educativas mediante
linguagens de programação apropriadas, como a LOGO ou PROLOG.

Os computadores alfabetizadores atuam ludicamente de forma oral
(através de um alfabeto que fala). Cada letra em posição errada na
palavra que está sendo construída provoca um sonoro alerta para o
alfabetizando.

O computador ensina, assim, a fazer sentenças via seu “*programa
construtor de sentenças*”. Até vinte e oito sentenças podem ser
montadas por vez. Além disso, noções de Matemática também podem ser
assimiladas por meio de uma calculadora falante, igualmente embutida.
Ensina a ler horas (sob forma digital ou não), a lidar com formas e
dimensões (inclusive a terceira dimensão) e com rudimentos de música
(audição e composição). Tudo isso é facilitado no âmbito dos
computadores alfabetizadores. Essa é, no entanto, apenas uma das
formas em que os computadores podem atuar como facilitadores em processos educativos. Uma forma inicial, aliás, de familiarização com o
computador, em que nem o aluno nem o professor necessitam aprender
linguagens computacionais ou a arte da programação.

# Computadores por dentro

## Eles contam como crianças

Como o computador faz as suas contas? Como dados, instruções de
programa e tudo o mais são armazenados em seu interior? Ao responder a
essas duas indagações, estaremos discutindo dois princípios de
funcionamento dos computadores. São princípios simples, ao contrário
do que se possa pensar. Para começar, o computador só conhece as
operações de soma e subtração. É isso mesmo! Se precisa multiplicar ou
dividir, o computador opera, então,
como fazíamos quando crianças: também somando ou subtraindo. Assim,
por exemplo, em nível de dispositivos eletrônicos, o computador
desconhece que 8 multiplicado por 6 = 48. Em vez disso, ele soma o
algarismo 8 seis vezes: 8 + 8 + 8 + 8 + 8 + 8 = 48. Ou seja: para
multiplicar, o computador tem de somar. Similarmente, para dividir
qualquer número por 14, vai subtraindo 14 de cada vez: o cociente é,
então, o número de vezes em que foi possível tirar 14. Assim, torna-se
desnecessário saber multiplicar e dividir. A inconveniência está no
excesso de trabalho, mas para o computador isso não tem importância,
dada a velocidade espantosa da máquina.

## Eles contam como índios

Os exemplos anteriores mostram como os computadores operam. Agem
desse modo, porém, sem utilizar os números decimais. Os números
referidos, 8, 48, 14, não existem para o computador, como também
qualquer outro número do sistema decimal (formado com algarismos de
0 a 9). Os números de base 10 são complicados
demais para se adaptar aos circuitos dos computadores. Tudo o que
entra para o computador tem de ser convertido para um código só de
dois símbolos: é o código ou sistema binário, exclusivamente formado
com os algarismos *0* e *1.* Esses dois símbolos bastam para
descrever os dois possíveis estados de um circuito eletrônico (ligado
ou desligado). O sistema que representa fenômenos por meio de dois
símbolos (o *sistema binário*), contudo, não é patrimônio exclusivo
dos computadores. É muito antigo e — de nenhum modo — foi criado só
para uso nos computadores, como muita gente pensa. Talvez venha a ser
mais uma das incríveis invenções dos chineses, há mais de quarenta
séculos. Ainda hoje, no entanto, pelo menos uma tribo de aborígines
que vive em uma ilha ao longo da costa da Austrália utiliza algo
similar à linguagem interna dos computadores. Esses índios contam de
1 a 6 assim: *Urapun* (= 1); *Ocosa* (= 2); *Ocosa-Urapun* (= 3);
*Ocosa-Ocora* (= 4); *Ocosa-Ocosa-Urapun* (= 5); *Ocosa-Ocosa-Ocosa* (= 6). Puro sistema binário!

## Memória: símbolos a reter


Em vez da aritmética binária dos índios, detalhemos agora, o caso
dessa aritmética nos computadores.

Cada um dos milhares de circuitos eletrônicos que compõem a memória do
computador pode ser ligado e desligado de forma incrivelmente rápida.
Quando a corrente elétrica passa através de um circuito, diz-se que
ele está ligado. Quando não passa qualquer corrente elétrica, o
circuito está desligado. Não há qualquer outro estado. Circuitos
ligados têm valor 1. E circuitos desligados têm valor 0. Como se vê,
somente dois símbolos são suficientes para descrever os estados dos
circuitos. São esses símbolos (correspondentes aos estados
momentâneos dos circuitos) que formam a chamada *linguagem de máquina*
ou linguagem nativa de zeros e uns. Tudo o que um computador possa
entender, memorizar e fazer tem de lhe ser comunicado (após
transformações), em última instância pelas combinações desses dois
sinais. Pelo menos, na computação mais convencional (não quântica, não
biológica, ou não óptica).

## Memória: símbolos a combinar

Mas, nós humanos, por comodidade, trabalhamos e passamos para o
computador números pertencentes ao sistema decimal. Como o
computador converte um número decimal para o número binário
correspondente, a ser retido em memória? No sistema de 10 símbolos
(*o sistema decimal)*, cada um desses símbolos (0, 1, 2, 3, 4, 5, 6,
7, 8 e 9)
— ao formarem números — terá, além de seu “valor absoluto”, um
“valor de posição”, o qual cresce da esquerda para a direita, em
sequência de potências de 10 (Assim: ...10–¹\ 10º, 10¹, 10²...). Exemplo: o número 325, formado apenas por
três símbolos — será expresso tanto em termos dos “valores absolutos”
dos seus símbolos quanto em termos dos “valores de posição” desses
símbolos — e será a seguinte soma: (5 x 100) + (2 x 10¹) + (3 x
10²).

No *sistema binário*, o valor de posição dos únicos símbolos
permitidos (0 e 1 que são, aliás, chamados de BIT) também cresce da
esquerda para a direita, mas agora em uma sequência de potências de 2
(Assim: ... 2–¹, 20, 2¹, 2²...). Por exemplo, o número 101000101 é um
número binário (contendo 9 bits, ou 9 zeros e uns somente) que
pode ser expresso em termos da seguinte sequência de potências de 2:

(1 x 28) + (0 x 27) + (1 x 26) + (0 x 25) + (0 x 24) +

(0 x 2³) + (1 x 2²) + (0 x 2¹) + (1 x 20) = 325.

Portanto, no sistema binário o símbolo vale sempre o dobro de seu
vizinho da direita: 0011 é a representação do número decimal 3 (uma
unidade à direita e mais o dobro à esquerda). O que quer dizer uma
equivalência entre símbolos decimais e binários. Assim temos:

(imagem 42)

## Memória: mediação em “palavras de computador”

Computadores também têm “*palavras*”, além de *bits*. Vamos explicar
isso. Diferentemente da palavra dos humanos que nem sempre vale, a
palavra de computador serve sempre para a medição de sua memória. O
tamanho da palavra de um computador serve como uma “unidade de
medida” de sua capacidade de armazenamento.

Ao serem teclados, não só números decimais são convertidos
automaticamente em números binários a residir em memória. Toda sorte
de símbolos alfabéticos, instruções de um programa e sinais de
pontuação também o são. Assim, uma vez teclada a letra *A*, ela é
aceita pelo computador como o código binário 01000001 e a letra *B*
como 01000010. Aqui, cada *0* e cada *1* é um *bit*, que é a menor
quantidade de informação a se alojar na memória de um computador.
Portanto, cada letra requer para seu armazenamento um total de 8 bits
(ou 8 estados de circuitos). Esses oito bits (representantes de
letras ou coisas quaisquer) são manipulados em grupo pelo computador
e recebem o nome de *byte*. Bytes são bits agrupados de 8 em 8; cada
agrupamento forma um byte. A memória do computador do meu primeiro
xodó — o IBM 1130 — por exemplo, era medida em termos de quantidades
de byte (década de 1970).

Por outro lado, define-se *palavra* de computador como um agrupamento
maior de bits — que vai de 16 a 512 bits — agrupamento esse usado como
medida de capacidade total de armazenagem do computador. Quase
sempre o tamanho de uma palavra é de 16 bits (2 bytes, portanto), ou
32 bits (4 bytes) ou ainda 64 bits (8 bytes). Concluindo: bits formam
bytes; e bytes são agrupados para formar palavras. Assim, o tamanho ou
a capacidade total da memória de um computador pode então ser medido
quer em termos de número máximo de bits que possam ficar
ligados/desligados; quer em número máximo de bytes, quer, finalmente,
em quantidades de palavras que possam ficar ligadas/desligadas.

# Computadores e seus tamanhos

## Famílias de computadores

A primeira pergunta a fazer neste ponto é: Como comparar os
computadores? Como eles podem ser agrupados em famílias de
computadores? Quais as diferenças que levam os computadores a serem
posicionados em uma certa classe e não em outra classe de máquina? Os
critérios para a classificação dos computadores variam bastante, cada
um desses critérios dando origem a diferentes famílias. Prefiro, no
entanto, discutir os tipos de computadores,
segundo o potencial (ou a capacidade) da máquina. Normalmente a
capacidade da máquina leva em conta o exame de fatores ou dos
seguintes cinco elementos classificatórios:
I)  tamanho físico do computador; II) tamanho da palavra formadora da
memória do computador; III) tamanho total da memória; IV) Velocidade
de processamento; V) custo do computador em dólar norte-americano;
(sendo que este último elemento, contudo, não será por nós
quantificado em virtude de sua transitoriedade).

O tamanho das “palavras de memória” (tamanho esse igual, ao longo da
memória) é dado pela quantidade de bytes (ou bits) que, representando
— por exemplo, uma instrução — pode ser manipulada de uma só vez. Já o
tamanho total da memória é a capacidade de representar uma
quantidade maior ou menor de letras, números e outros sinais. É sua
capacidade total de armazenamento na memória, em razão da soma das
capacidades de todas as palavras, como exemplificamos abaixo.

Se, em um caso específico, um dado computador tem 32 mil bytes, então
este é o tamanho de sua memória. Em termos de palavra de computador,
esse tamanho equivale a dizer que esse computador tem uma armazenagem
de 8 mil palavras de
memória, se cada palavra desse computador tiver 4 bytes (ou seja, 32
mil bytes/4 bytes por palavra = 8 mil palavras). Finalmente, o
critério da velocidade (ou tempo) de processamento se refere ao tempo
que um computador precisa para carregar um dado ou uma instrução de
sua memória para seu processador. Não se pode esquecer que, embora
estocada na memória, qualquer instrução só pode ser executada se
previamente carregada para a unidade responsável pelo processamento.

Os computadores — considerados esses critérios — podem então ser
organizados em cinco grandes classes:

-   Computadores móveis: *handhelders*, *palmtops* e *notebooks*;

-   Computadores pessoais (PCs);

-   Minicomputadores;

-   Computadores de grande porte (*Mainframes*) e

-   Supercomputadores.

## Computadores móveis: *handhelders*, *palmtops* e *notebooks*

*Handhelders* (ou handhelds) e *palmtops* são nomes que fazem
referência à palavra mão (*hand*) para lembrarem
que eles podem ser segurados pela mão, ao serem postos em operação.
Com a aparência enganosa de calculadoras, de fato, são computadores —
pois possuem softwares registrados em memória — que viabilizam uma
importante classe de computação, a chamada computação móvel. A meta na
computação móvel é desenvolver ambientes de modo a ter tudo se
movendo: servidores, estações-base, roteadores/agentes, sub-redes,
*intranets*. Uma computação que daqui para frente se tornará cada vez
mais: cômoda; portátil, ubíqua e utilíssima. Os *notebooks* ou
*laptops* são o “fino da bossa” dessa computação móvel, funcionando
praticamente como potentes PCs, em forma portátil.

*Handhelders* e *palmtops* funcionam, sobretudo, como “organizadores”
da vida das pessoas, das fazendas de gado e das plantações. Do centro
de suas fazendas, o usuário poderá, por exemplo: I) organizar e
cumprir sua agenda;

I)  manter-se em dia com suas tarefas diárias enquanto estiver longe
de sua mesa de trabalho; III) inserir sua agenda no *date book* do
sistema e definir um alarme para lembrá-lo de reuniões importantes; IV) manter todos os nomes, endereços e
números de telefone de contato no *address book*; V) atribuir prioridades e uma data final às tarefas
no *to do list*; VI) fazer breves anotações diretamente na tela usando
o *note pad*; VII) ver, editar e redigir mensagens de correio
eletrônico, mesmo quando estiver ocupado com outra tarefa; e VIII)
transferir suas informações para outros computadores.

Computadores pessoais ou
------------------------

***Personal Computers* (PCs)**

Nas sociedades em níveis avançados de informatização, o PC faz parte
do cenário familiar diário. Daí sua denominação. Ajuda nos cálculos
do orçamento e dos negócios familiares, na preparação de receitas
culinárias, no entretenimento da família e na familiarização das
crianças com o mundo dos computadores. No começo havia uma distinção
clara entre *micros domésticos* que eram uma classe mais simples de
computadores residenciais e os ditos *micros profissionais*. Tudo era
uma questão de acessórios, ou de maior ou menor memória. Hoje, com
as facilidades de personalização e upgrades dos micros essa
diferença já não existe.

Computadores dessa classe têm uma memória de 256 mil bytes e palavras
de 16 bits. Geralmente são vendidos a preços que variam muito a
depender do valor do dólar. O tempo de processamento é de 1
microssegundo. Os microcomputadores profissionais são, geralmente, os
mais apropriados para a informatização de pequenos negócios,
escritórios e para a aplicação de informática educativa em escolas
do ensino médio.

Minicomputadores
----------------

Os minicomputadores em geral têm 16 bits por palavra de computador,
característica em comum aos micros profissionais. Sua memória, porém,
começa com 512 mil bytes e o tempo de acesso a ela é de 250
nanossegundos. É bom lembrar que 1 nanossegundo corresponde à fração
1/1.000.000.000 = 10–9 de segundo (a bilionésima parte do segundo). A
alta velocidade de processamento presente nesses computadores faz
deles os preferidos para a pesquisa científica, sobretudo nas
universidades medianas do mundo inteiro, como é o caso das estações de
trabalho

*Sun* e os Sistemas 6000 da IBM, cujas velocidades já são medidas em
termos de operações (conjunto de operações e não só uma operação) de
ponto flutuante ou operações sobre números reais por segundo (“*flop*s
= *floating point operations per second*”). Ambas são máquinas na casa
dos *megaflops* (Mflops = 1 milhão de flops ou operações sobre reais).
Um DEC Vax 9000, também muito preferido em universidades estrangeiras,
chega a 125 Mflops.

**Computador de grande porte ou *Mainframes***

Comumente chamados de *mainframe* (pronuncia-se “menfreim”), são os
computadores das grandes empresas e principais administrações
governamentais. Têm memórias internas que começam com 4 milhões de
bytes, palavras de 32 bits e uma velocidade de processamento de 50
nanossegundos. Bom exemplo dessa família de computadores é o
*mainframe* IBM 3090, utilizado, sobretudo, em grandes empresas e o
qual pode alcançar 414 Mflops.

Supercomputadores
-----------------

O exemplo de supercomputador mais moderno é o do governo
norte-americano que foi apresentado em 2001 e é capaz de simular a
explosão de uma bomba nuclear. É o *Asci White*, ao custo de US\$
110 milhões e o qual é dividido em unidades que ocupam o espaço de
duas quadras de basquete. Segundo a IBM, ele pode realizar em um
segundo operações que uma calculadora levaria 10 milhões de anos.

Em geral, com memórias começando com 4 milhões de bytes, os
supercomputadores sintetizam, neste momento, todos os avanços do
ponto de vista de equipamentos (hardware). Têm palavras de 64 bits e
o acesso à memória dá-se em 10 nanossegundos. É interessante notar que
um circuito nesses computadores fica ligado/desligado em um tempo
medido em picossegundos, ou seja, 10–¹² do segundo. Essa estupenda
velocidade permite que o supercomputador CRAY-1, por exemplo, possa
multiplicar 240 milhões de pares de números de dezesseis algarismos em
apenas um único segundo. Aliás, o CRAY-1 e o CRAY-2 são bem
representativos dessa classe de computadores, de

extraordinária relevância em áreas estratégicas como: pesquisa
espacial e meteorológica, pesquisa em física atômica, pesquisa militar
e segurança.

Supercomputador da UFRGS
------------------------

Restritos ao clube fechado das grandes potências, são esses os
computadores que, ao longo dos anos, têm levado o Brasil a se explicar
ao governo norte-americano sempre que são empreendidas tentativas de
aquisição e domínio dessa tecnologia. Supercomputador “é o Rolls Royce
dos computadores. Perto dele, os outros parecem umas carroças”, como
bem se expressava a doutora Liane Tarouco ao receber em sua
universidade, a Universidade federal do Rio Grande do Sul (UFRGS) — o
primeiro supercomputador da América do Sul — um CRAY Y-MP2E (julho,
1992). Com dois processadores vetoriais, ele se parece com um simples
“armário” de 1,70 m, com unidade de disco, unidade de refrigeração e
uma “caixa preta” que o liga à sua fábrica nos Estados Unidos, para
efeito de diagnóstico (segundo dizem), ele é capaz de fazer 660
milhões de operações sobre

números reais por segundo (660 Mflops). A comparação com um PC, por
exemplo, chega a ser covardia: PCs podem levar uma década inteira para
resolver um certo problema que um supercomputador decifra em poucas
horas.

Supercomputador da USP
----------------------

O caso ocorrido com a Universidade de São Paulo (USP) é bem
representativo de quanto nosso país ainda tem de “bater continência”
para potências mundiais. Até muito recentemente, a USP não era livre
para adquirir e dominar essa tecnologia. O supercomputador da UFRGS
foi adquirido em uma negociação em que concorreu uma verdadeira
constelação favorável de fatores, combinando cabeças arejadas tanto
no Ministério da Ciência e Tecnologia quanto no Ministério de Educação
(no tempo do prof. José Goldemberg), quanto na UFRGS. Mas, no caso da
USP, a lei de mercado da economia — já desmoralizada pelo capitalismo
monopolista — foi anulada pelas pressões do governo norte-americano
que vetou a aquisição do supercomputador quando essa universidade se
esforçava para adquiri-lo quase ao mesmo tempo que

a UFRGS. O governo norte-americano liberou a venda do super CRAY
Y-MP2E para a UFRGS e teve de notificar essa venda ao Japão, por
acordos bilaterais (o outro fabricante de supercomputadores), mas
alega que a USP é suspeita de um “possível mau uso”, por desenvolver
pesquisas em atividades não divulgadas.

Por fim, o Laboratório de Computação Científica Avançada da USP
conseguiu adquirir seu CRAY sv1 que possui Multi-Streaming Processors
que possibilitam a distribuição do processamento por grupos de
processadores. São 8 processadores de tecnologia sv1, 300 MHz, memó-
ria de 16 Gbytes e Sistema Operacional ÚNICOS 10.0.08. Seu sistema
operacional possui alta performance para processamento *batch*,
manipulação de dados e alocação de recursos e segurança.

Supercomputador do Inpe
-----------------------

Também o Laboratório Associado de Computação e Matemática Aplicada do
Instituto Nacional de Pesquisas Espaciais (Inpe) iniciou, já em 2006,
a operação de um

supercomputador CRAY XD1, adquirido no escopo do projeto Finep
“Tecnologia em Grade Climatológica de Mesoescala”, um projeto
relacionado à modelagem de fenômenos do Sistema Terrestre que objetiva
testar a viabilidade do uso operacional de grades computacionais em
previsão de clima regional. A grade é constituída por computadores de
alto desempenho, distribuídos pelo país e acessíveis por portal único.
Cada nó nessa grade controlada pelo CRAY XD1 executa um modelo atmos-
férico regional.

![](media/image3.png){width="0.8965430883639545in"
height="0.37385389326334206in"}

COMPUTADORES,
=============

**SUAS LINGUAGENS E APLICAÇÕES**

Dando ordens em linguagens inventadas
-------------------------------------

Seria ótimo se as pessoas pudessem se comunicar com o computador
utilizando suas próprias linguagens — as chamadas *linguagens
naturais*. Dariam suas instruções em português ou francês, por
exemplo, e imediatamente elas seriam aceitas e processadas pelos
computadores livrando as pessoas do sacrifício de inventar e aprender
*linguagens computacionais* (ou artificiais). Isso porém continuará
sendo, talvez por algum tempo ainda, apenas uma das

grandes promessas de Informática, no campo de *Processamento de
Linguagens Naturais* (ramo da Inteligência Artificial). Processar
linguagens naturais significa fazer o computador entender a própria
fala humana. Você já pensou sobre as implicações disto? Entender a
fala (*speech understanding*), como ainda entender a forma escrita —
sintaxe e semântica — de nossos idiomas (*text understanding*)
constitui tarefa gigantesca em pleno desenvolvimento, inclusive a
tarefa de tradução e de geração automática de textos. Até lá, no
entanto, a comunicação humana com os computadores tem de ser feita por
meio das linguagens artificiais computacionais ou *linguagens de
programação*.

Que linguagem falar?
--------------------

Hoje, essas linguagens se multiplicam velozmente já ultrapassando
centenas de linguagens e dialetos. Como acontece com os computadores,
também elas podem ser agrupadas em classes, de acordo com um dado
critério; por exemplo, o conjunto das facilidades proporcionadas pela
linguagem. Se ela é de fácil manuseio, tem recursos

variados para programação e se parece com as linguagens humanas, então
é uma linguagem criada com o pensamento voltado para o programador.

Caso contrário, costuma-se dizer que a linguagem está mais voltada
para atender às características da máquina do que para facilitar a
vida do programador. É uma linguagem mais difícil e não amigável. De
acordo com esse critério, as linguagens podem ser enquadradas em
quatro classes: I) linguagens de baixo nível; lI) linguagens de alto
nível; III) linguagens de muito alto nível; e IV) linguagens de
altíssimo nível (hoje em gestação). Aqui, os quatro níveis ascendentes
indicam que as linguagens neles agrupadas devem crescer em facili-
dades de programação e em semelhanças com a linguagem humana. Assim,
uma linguagem de alto nível (a PASCAL, por exemplo) deve ser de uso
mais fácil que uma linguagem de baixo nível como ASSEMBLY.

ASSEMBLY
--------

Nascido após 1950, este foi o primeiro grupo de linguagens a surgir.
ASSEMBLY (não confundir com

ASSEMBLER, que é o nome de um programa tradutor) é a linguagem
representativa das linguagens de baixo nível. Quando se diz que
ASSEMBLY é de baixo nível, não significa que a linguagem não presta.
Ao contrário, ASSEMBLY é eficiente e programas escritos nessa lin-
guagem de zeros e uns (*linguagem de máquina*) a que tudo é reduzido
no interior do computador. ASSEMBLY é também uma linguagem escrava de
um único tipo de computador: só pode ser usada nos computadores para
os quais foi inventada, daí seu pouco interesse para o não
profissional.

COBOL, ALGOL, FORTRAN, PL-1, BASIC
----------------------------------

Excluída a ASSEMBLY, todas as outras linguagens têm a característica
da “portabilidade” que permite ao programador comunicar-se com muitos
computadores diferentes na mesma linguagem. É o caso do grupo ci-
tado, que representa as primeiras linguagens de alto nível, surgidas
após 1956. Enquanto a COBOL foi desenvolvida para programar na área
industrial e de negócios,

FORTRAN, ALGOL e BASIC foram criadas para a área científica
educacional. A PL -1, por sua vez, tentou ser uma linguagem de uso
tanto em âmbito comercial quanto científico, mas fracassou. Hoje, com
o aparecimento das linguagens do tipo multiuso, compactas e ele-
gantes, tanto a PL -1 como também a COBOL já estão em pleno desuso.

PASCAL, C, MODULA-2, JAVA
-------------------------

Este é um grupo mais moderno de linguagens, um grupo das chamadas
linguagens de alto nível. Essas quatro linguagens podem ser usadas
em quaisquer aplicações e são particularmente importantes para o
ensino da própria Ciência da Programação. Elas têm em comum a ma-
neira de dar ordens ao computador. Programas nelas escritos dizem,
imperativamente, ao computador COMO um certo problema deve ser
resolvido. São, portanto, exemplos de *linguagens imperativas* ou
algorítmicas, que se opõem às *linguagens declarativas*. As linguagens
declarativas, ao contrário de dizerem “como algoritmicamente”

resolver problemas, declaram assertivas para o computador (daí a
denominação), detalhando sobretudo o QUE deve ser executado pela
máquina. Isto significa algo fundamental em informática. Significa
liberar o programador de tudo que envolver algoritmos.

*PASCAL* — uma linguagem suíça — surgiu das experiências anteriores,
com a linguagem ALGOL-60. Ela foi desenvolvida por Niklaus Wirth, no
Instituto de Tecnologia de Zurique (começo dos anos 1970),
justamente para servir de apoio ao ensino de informática. É uma
linguagem compacta, de uso geral, mas pensada para ensinar e
praticar a Informática. Quanto à linguagem C, foi desenvolvida por
Dennis Ritchie, na América, e é reconhecidamente uma linguagem rica
em recursos de programação, embora de difícil aprendizagem. Poucos
profissionais “ousam aprender a linguagem C, sem buscar a ajuda de al-
guém já experiente na linguagem”. MODULA-2, por sua vez, foi
desenvolvida pelo mesmo criador da PASCAL, no começo de 1980.

JAVA (cidade de origem de famoso café de exportação) é uma linguagem
muito nova (Iançada em 23 de maio de 1995, pelo Escritório de Ciência
da Sun Microsystems,

empresa mundialmente conhecida no ramo de redes de computadores),
muito embora pertencendo a uma família mais antiga de linguagens: a
família das *linguagens orientadas a objetos*, originada em 1980. É
uma linguagem com imensas vantagens. Pode ser executada de celulares a
mainframes. Suas características: I) orientada a objetos; II) robusta
e segura; III) distribuída e portátil; IV) arquitetura neutra; V)
interpretada, mas de alta performance; e VI) simples.

A linguagem é simples, mas não tanto. Baseada na linguagem C++ (que é
complicada), a JAVA herda semelhanças com C++ que não são fáceis.
Mas, JAVA possui apenas seis instruções e isso é bom: duas instruções
para tomada de decisão, três instruções de repetição, e uma instrução
para proteção de código (proteção de pedaços de programas).

LOGO, MICRO-PROLOG, COMAL, PILOT
--------------------------------

Grupo de excelentes linguagens para quem quer aprender a programar
pela primeira vez. Daí serem recomendadas como linguagens
apropriadas ao ensino fundamental.

LISP, PROLOG, SMALLTALK
-----------------------

As linguagens deste grupo têm duas características. São exemplos de
linguagens de muito alto nível e, ao mesmo tempo, de linguagens
declarativas usadas na tecnologia de Inteligência Artificial (ramo
da Informática). SMALLTALK é uma linguagem reservada a um tipo muito
particular de programação: a *programação orientada para objeto*. Foi
a primeira linguagem a descobrir e implementar a chamada “tecnologia
de objetos” em informática (1980, Instituto de Pesquisas da Xerox),
quando ainda nem se pensava em linguagens representadoras ou proces-
sadoras de objetos, como JAVA.

Por outro lado, LISP e PROLOG estão hoje para o profissional de
computação como o latim e o grego estavam para o homem culto de
outrora. LISP foi criada por John McCarthy e seus estudantes do
Massachusetts Institute of Technology (MIT, EUA), no início dos anos
1960, para programar problemas não numéricos.

PROLOG foi criada pelos franceses em 1975 (em Marselha, onde este
autor estagiou em 1999), aperfeiçoada pelos ingleses e foi a linguagem
escolhida pelos japoneses

para servir de base à quinta geração de computadores, durante os
anos 1980. PROLOG — termo nascido de “PRO(gramming) in LOG(ic)” —
representa um esforço de trazer para o computador o modo humano de
raciocinar, por meio da Lógica. É a primeira vez que o computador
é levado a fazer raciocínios lógicos, o que é muito mais significativo
do que simplesmente processar dados. No caso foi implementado,
computacionalmente, um dos ramos da Lógica Simbólica, a chamada Lógica
de Predicados. Esta lógica adaptada continua sendo um paradigma
revolucionário da programação computacional: o paradigma
declarativo, ali que o usuário vai simplesmente declarando
realidades (fatos e regras) para o computador poder embasar seus
raciocínios.

Aplicações de computadores
--------------------------

As linguagens são empregadas para resolver problemas, em aplicações
que se espalham pela sociedade. Já salientamos que os computadores
são “criaturas” altamente invasivas. Invadem a vida das pessoas, das
empresas, dos

Institutos de pesquisa, dos departamentos governamentais, das
universidades e escolas, em uma velocidade que chega a refletir a
modernidade de um povo. Mesmo em sociedades como a nossa, onde o nível
de informatização ainda não é tão significativo, até mesmo o sertanejo
aposentado que recebe seu carnê de aposentadoria já começa a ter sua
primeira experiência com computadores. Esta generalização do uso dos
computadores só pode causar impactos sociais fundamentais, por
exemplo, sobre a criação ou a supressão de empregos, a qualificação
do trabalho, a liberdade das pessoas e muitos outros aspectos. O
computador, sob enfoque interdisciplinar, “é portador de uma
racionalidade especifica, que impõe novas formas de organização, de
relações sociais de produção, de divisão social do trabalho; em
suma, o computador é portador de um projeto novo de sociedade”.
Partindo-se desta evidência, será então possível indicar as direções
por onde avançam os computadores nas modernas sociedades? Quais são,
em termos mundiais, as aplicações mais frequentes desses
computadores invasivos?

Aplicações convencionais: folhas de pagamento
---------------------------------------------

Costumo agrupar as aplicações dos computadores em três grandes
classes: *aplicações convencionais*, *aplicações intermediárias* e
*aplicações avançadas*. Nas aplicações convencionais não há mais
desafios a vencer, ou nada a fazer do ponto de vista tecnológico: já
estão prontas nas prateleiras; é só comprar, no máximo adaptar e
usar. É o caso de *Folhas de Pagamento*, *Faturamento de Empresas*,
*Contas a Pagar/Receber*, *Controle de Estoques* etc. Constituem o
“feijão com arroz” do uso computacional em qualquer lugar.

Aplicações intermediárias em complexidade: sistemas de informação
-----------------------------------------------------------------

*Sistemas de Informação* ora se referem ao ramo da informática
aplicada às empresas e organizações (em oposição à informática
teórica), ora se referem aos próprios softwares de gestão empresarial
ou organizacional. Em geral, constituem aplicações intermediárias ou
que estão a meio passo entre as convencionais e as avançadas. Têm

duas características básicas. Primeiro, são desenvolvidas caso a caso,
considerando as peculiaridades do usuário. Segundo, requerem uma
visão integral (visão sistêmica) do ambiente a ser informatizado.
Geralmente são usos computacionais cuja implantação requer um modelo
conceitual ou algum método teórico como base para a aplicação, di-
ferentemente de softwares isolados e restritos a uma tarefa.

Portanto, Sistema de Informação é informática aplicada a empresas e
organizações, por sistemas de software. Compreende, sobretudo, as
aplicações em: I) Sistemas de Processamento de Transações
(“*transaction processing systems*” — TPS); II) Sistemas de
Informações Gerenciais (“*management information systems*” — MIS); e,
mais recentemente, III) Sistemas de Apoio à Decisão (“*decision
support systems*” — DSS).

Aplicações intermediárias em complexidade: suporte de decisões
--------------------------------------------------------------

Todos os projetos informáticos considerados de *Suporte de
Decisões*, quer se trate de decisão empresarial ou governamental,
são aplicações intermediárias. A *Automação*

*de Fábricas* é outro exemplo, como também a *Gestão de Projetos
Complexos*, *Planejamentos de Longo Prazo* e todas as utilizações
envolvendo a *Simulação* de situações. Neste suporte de decisões,
geralmente métodos da Pesquisa Operacional (PERT, FILAS, Programação
Linear, Controle de Estoques etc.) devem ser automatizados e
apresentam graus diversos de complexidade. A Informática, porem, já
provou ter encontrado soluções adequadas para a maioria dessas
aplicações.

Aplicações avançadas: desenho tridimensional
--------------------------------------------

Por último, as aplicações avançadas constituem, atualmente, o
interesse maior de indústrias, cientistas e governos, que buscam e
lidam com *metodologias informáticas futuristas*. O exemplo do desenho
ou da projeção por computador (*drafting*) é bem representativo dessa
categoria de aplicações. A tarefa do desenho tem hoje enorme
importância dado o impacto sobre o mundo da produção industrial. É o
chamado *Desenho Assistido por Computador* (CAD — *Computer-Aided
Design*), de extraordinárias

aplicações nos processos de *Fabricação Assistida por Computador*
(CAM — *Computer-Aided Manufacturing*). Os sistemas de desenho vão
dos mais simples, quando desenhado em uma só dimensão (1-D), passando
pelo desenho em duas dimensões (2-D), até os sistemas interativos
chamados modeladores geométricos (3-D). Um projetista mecânico,
por exemplo, que usa esses sistemas, pode até não conhecer coisa
nenhuma de geometria, nem da tradicional, nem da computacional, mas
os programas lhe permitem manipular objetos como cubos, cilindros,
segmentos, arcos, círculos etc. O projetista combina essas figuras (de
acordo com os comandos que emite) de modo a obter a peça mecânica mais
complexa que está a projetar. Na área, porém, o desafio maior está
sendo o aprimoramento da tecnologia de *Reconhecimento de Padrões* (ou
*Pattern Recognition*), por meio da qual o computador tem de “en-
xergar” em três dimensões. Uma vez “enxergado”, ele pode então
manipular ou desenhar o que foi “enxergado”. Os obstáculos? São
muitos. Para começar, a técnica de *Reconhecimento de Padrões* por
computador simula artificialmente a visão humana. E isso já é uma
tarefa exaustiva. Outra dificuldade é externa aos computadores

e diz respeito à visão humana propriamente dita. O conhecimento que
se tem de vários aspectos da visão humana, sobretudo em relação às
diversas funções exercidas em nível de córtex cerebral e sinapses
nervosas, ainda é bastante limitado.

Aplicações avançadas: diagnose médica
-------------------------------------

Além do Desenho Tridimensional e Industrial, outras aplicações
avançadas estão em pleno desenvolvimento e continuarão a progredir por
tempo difícil de prever. São aplicações nas áreas de *Diagnose* (de
problemas médicos, telefônicos, de redes de computadores, de
circuitos, de instrumentos elétricos e mecânicos), nas áreas de
*Interpretação* e *Análise*, na área de *Monitoração* (de funções da
vida humana ou funções vitais, monitoração de fábricas, de ameaças
militares) e no campo da Educação, como a *Instrução Assistida por
Computador* e *Tutores Inteligentes*. Aplicações avançadas
compreendem, também, todo o esforço ora em desenvolvimento nos
laboratórios para a *Compreensão de Linguagens Naturais* e para a
*Tradução Automática*,

como também a *Visão*, a *Audição*, a *Olfação*, o *Tato*, o *Pa-
ladar* e a *Cinestesia por Computador-Robô*. Todo o desenvolvimento
da Robótica (que precisa levar os robôs a ver, apalpar, segurar,
ouvir, andar etc.), como se vê, há de passar por esta automação dos
seis sentidos do homem, já iniciada.

*Programação Automática de Computadores* é outro capítulo das
aplicações, também em desenvolvimento. Ou seja: um capítulo que se
concentra em esforços a fim de automatizar a própria tarefa de
desenvolver programas computacionais. Nos estágios atuais, a
preocupação é ainda com o desenvolvimento de amplas e poderosas fer-
ramentas para a programação (os ambientes de desenvolvimento). Pois,
a tarefa da programação nela mesma, por incrível que pareça — até
recentemente — ainda era extremamente “braçal”, com pouca ajuda do
computador — como os sistemas editores de texto e os analisadores sin-
tático-semânticos ou compiladores. Mas o grande objetivo nesta área
será o de levar o computador a se autoprogramar, no final de contas.

São essas, portanto, algumas das pesquisas de ponta que têm desafiado
os cientistas da computação. Por esses

caminhos passam (e passarão) as aplicações dos modernos
computadores, com todas as suas transformações. Passam e exigem — não
que saibamos todos programar computadores — que a sociedade desenvolva
seu modo de pensar e de gerir a Informática e os computadores. É
preciso, sobretudo, que cada cidadão aprenda a analisar o trabalho que
desempenha em função das imensas possibilidades dos computadores.

![](media/image3.png){width="0.8965288713910761in"
height="0.37385389326334206in"}

COMPUTVADOREIS INITEILIGENTES
=============================

Gerações de computador
----------------------

Os primeiros computadores — a chamada primeira geração de computadores
— tinha por base tubos a vácuo. A segunda, os transistores. A
terceira, circuitos integrados. A quarta, circuitos altamente
integrados, os famosos VLSIS (*Very Large Scale Integration*), que
dominaram os anos 1980. A quinta geração vai mais longe. Segundo as
previsões, dominará o mundo.

A quinta geração é a historia de uma nova “super-raça” de computadores
— os *computadores inteligentes*, complexos em hardware, mas cuja
inteligência está, sobretudo, em seus

softwares. Os japoneses provocaram a atenção do mundo e até a inveja
dos concorrentes norte-americanos quando, em outubro de 1981, o
Instituto Japonês para Indústria e Comércio (ICOT) anunciou o
projeto de Quinta Geração que deixou estonteada a comunidade de
informática norte-americana e europeia, tamanha era a ousadia das
propostas conhecidas como o desafio japonês. Essas propostas
japonesas de lá para cá sofreram revezes porque o que estava previsto
não acontecera com a velocidade esperada, em especial em relação ao
final da década de 1980. Mas os computadores inteligentes já são
hoje uma realidade, não apenas na academia, mas, também na indústria e
nos mercados. Qual é a essência desses computadores? Em que sentido
eles são inteligentes?

Inteligência via software
-------------------------

Os computadores inteligentes objetivam resolver duas classes
principais de problemas:

CLASSE 1: problemas de fácil solução pelos humanos, mas de
dificílima solução por computadores.

CLASSE 2: problemas de difícil solução tanto para humanos quanto para
computadores.

Ao contrário das classes 1 e 2, há também uma classe 3 de problemas
que são as tarefas difíceis para os humanos, mas, fáceis e até
triviais para os computadores. Contudo, este mundo de problemas não
está reservado diretamente aos computadores inteligentes. Problemas
difíceis (visto que exaustivos) para humanos, mas fáceis para
máquinas, são o reino dos nossos computadores normais ou seriais.
Aqueles problemas cuja computação — ANTES MESMO DE EXIGIR INTELIGÊNCIA
— está muito mais orientada para: I) *grandes números*; II)
“*mastigação de números*” ou “*calculeiras*”; III) *velocidade*; IV)
“*trabalho braçal*”; V) *controle de estoque*s; VI) *atividades de
intermediação* (revendedores de automóvel, agentes de viagem que têm
o rifle da internet apontado para sua nuca); e VII) *tarefas
repetitivas* (trabalhadores de fábrica envolvidos em produção).

Problemas de fácil solução pelos humanos (classe 1) são, por exemplo:
ação de ver/enxergar, ouvir, degustar, tatear, olfação, mover-se na
direção desejada, sentir emoções. Ou seja: tudo aquilo em que os
computadores ainda hoje “apanham feio”, diante dos humanos.

Por outro lado, problemas de complexa solução tanto para humanos como
para computadores (classe 2) são, por

exemplo: I) *diagnóstico* (de falhas em hardware, de redes de
computadores, de componentes, de problemas médicos);

II\) *configuração* (seleção e arranjo de componentes computacionais);
III) *interpretação e análise* (de dados geológicos, cardíacos,
cerebrais e respiratórios); IV) *monitoração* (de ameaças militares,
de funções vitais em pacientes hospitalares, de fábricas e equipamentos,
de plantas industriais, de serviços governamentais); V) *planejamento*
(da gestão de projetos, de patrimônio, compromissos e “portfólios”, da
produção de placas de circuitos); VI*) interfaces inteligentes* (em
comunicação humana com programas computacionais, em comunicação com
bancos de dados múltiplos, em painéis de controle e em instrumentos de
hardware); VII) *sistemas em linguagens naturais* (comunicação em
português com bancos de dados); VIII) *projeto de sistemas* (em sistemas
de transporte, pontes e barragens); e IX) *desenvolvimento de sistemas*
(em programação automática, sobretudo).

Atuar na resolução de quaisquer problemas das classes 1 e 2 requer
inteligência. Sobre isso, é até fácil concordar. Mas: *O que é
Inteligência*? A maior dificuldade em definir os *computadores
inteligentes* reside justamente aqui. Não há unanimidade conceitual
até hoje sobre inteligência, nem dentro

nem fora da comunidade de informática. Daí a existência de verdadeiras
escolas de pensamento sobre os computadores inteligentes. Mas hoje,
uma coisa é tida como certa: inteligência é conhecimento. Pode até
ser muitas outras coisas, podendo ter muitas outras facetas. Mas
demonstra inteligência quem aprende/apreende conhecimentos.

Computador inteligente = Dispositivos
-------------------------------------

**+ Bancos de Conhecimentos + Inferências**

Definimos computadores inteligentes, sobretudo, em virtude dos
*conhecimentos* que eles possam adquirir e exibir para resolver
problemas, usando seus complexos dispositivos. São também definidos
como uma *coleção tripartite de recursos*, de acordo com a expressão
já enunciada (Dispositivos + Bancos de Conhecimentos + Inferências).
Do lado dos dispositivos (hardware), computadores inteligentes não
terão mais um só processador (uma única Unidade Central de
Processamento), como ocorre atualmente com a maioria dos computadores.
Esse hardware está sendo concebido de modo a conter grande quantidade
de

processadores altamente interligados, como já nos referimos ao
discutirmos os supercomputadores.

Do lado dos programas, o software inteligente é construído ou é
movido a *conhecimentos* (orientados para O QUE fazer), em vez de
movidos a algoritmos (orientados para o COMO fazer), como acontece nos
computadores normais. Ou seja: o combustível do *software inteligente*
é o conhecimento sobre o mundo da atuação desses computadores. Mas
surge agora um novo problema para os desenvolvedores que,
fundamentalmente, nos tira do domínio propriamente da informática
para descambar no reino da filosofia: *O que é Conhecimento*? Vamos
fugir das filigranas filosóficas envolvendo o conhecimento (e como são
muitas as filigranas dos filósofos!) para, assim, melhor podermos
definir conhecimento, do modo mais operacional possível, antes de
continuarmos com a caracterização desses computadores inteligentes:

*Conhecimento = informação + ação*

*Informação*, conceitualmente, já foi abordada ao tratarmos dos
computadores em essência. Mas conhecimento é muito mais do que simples
informação (ao contrário do que muita gente pensa). Por exemplo:
suponha que alguém, lá

em uma esquina da vida, consiga a exata informação sobre a taxa de
câmbio do dólar norte-americano (US\$), em certo dia — o seu preço em
uma moeda local, como o real (R\$). Descobrir essa taxa de câmbio pode
ser apenas uma *Informação* sem qualquer *Ação* correspondente, ou
sem qualquer emprego dessa informação. Apenas defrontar-se com essa
informação, por si só, e sem aplicá-la ou dela nada usufruir não
implica conhecimento — computacionalmente falando. *Conhecimento*,
desse modo, só existirá quando essa sua componente de *Informação*
está em ponto de uso na Ação certa, na hora certa e pela pessoa certa.
O foco do conhecimento, portanto, é a *Ação* que provoca mudanças,
transformações e, sobretudo, resolve os problemas (das classes 1 e
2). *Experts*, em quaisquer das áreas, atuam sempre assim:
descobrindo, adquirindo informação relevante, resolvendo as
incertezas (“informação é aquela parte da comunicação que resolve a
incerteza”), e aplicando-a em

conhecimentos que resolvem problemas.

Os computadores inteligentes atuam de modo semelhante. Eles adquirem
conhecimentos de tipos diversos, de fontes diversas e de formas
diversas, mas sobretudo, adquirem aqueles conhecimentos implícitos que
residem

nas cabeças dos “expertos” humanos (usando aqui a tradução correta
de *expert*, em vez de “especialista”). *Conhecimentos implícitos*
se tornam então *conhecimentos explícitos*, ao saírem da cabeça dos
expertos para, de alguma forma, passar a mover os computadores
inteligentes, sobretudo mediante três tipos de software: I) bancos de
conhecimentos; II) mecanismos de inferência; e III) interfaces
inteligentes. O que significa cada um desses tipos de software?

Bancos de conhecimentos
-----------------------

São também apelidados de “bases de conhecimentos”. O que são eles? São
grandes, medianas ou pequenas coleções de conhecimentos: I)
pertencentes a algum domínio do saber humano; II) originados de alguma
fonte bem definida; e III) explícita e operacionalmente organizados,
segundo algum esquema conhecível pelo computador. Assim entendidos,
bancos de conhecimentos são a fonte de toda a inteligência desses
computadores. Ou, dizendo de outro modo — conhecimento é o primeiro
nome da inteligência; podendo esses conhecimentos, organizados

em bancos de conhecimentos, serem particionados em tipos diversos:

*Banco de conhecimentos = conhecimento1 + conhecimento2*

*+ ... + conhecimenton*

Conhecimentos bem populares são aqueles representáveis em forma de
regras. Vejamos um exemplo de conhecimento facilmente armazenável em
qualquer microcomputador de hoje, é extraído do reino da mecânica
de automóveis. O que acontece quando um bom mecânico está seguro das
informações *A* e *B* a seguir?

*A*: O motor do automóvel está bom.

*B*: Os pneus do automóvel também estão em ordem.

Supondo que esses fatos sejam verdadeiros (ou já estejam
computacionalmente armazenados), nosso mecânico assim como as demais
pessoas (ou o próprio computador) experientes em mecânica já trazem —
na “ponta da língua” (ou na “ponta dos dedos”, como dizem os
britânicos) — um conhecimento heurístico ou empírico sobre carros, na
forma de uma regra — como a

seguinte e vai fazer uso das premissas *A* e *B* que possam ser dadas
ao computador:

*C*: **SE** *o motor do automóvel está bom,*

**E** *os pneus do automóvel estão em ordem*

**ENTÃO** *o automóvel “anda”*.

Um computador inteligente ao dispor de um conhecimento C — como este
— irá diagnosticar um certo automóvel e concluir que ele tem ou não
condições de funcionar ou andar. O que ele faz, basicamente, é aplicar
a regra *C*, fazendo inferências a partir das premissas *A* e *B* e,
facilmente, exibindo suas conclusões para um usuário que não precisa
saber programar para consultar sistemas inteligentes. Imagine você,
então, a riqueza, o poder e a onipresença desses sistemas formados de
conhecimentos.

Mecanismo de inferências
------------------------

Em contraste com os convencionais *bancos de dados*, bem estruturados
até demais, porém, de difícil consulta por parte do usuário (você tem
de ser programador para

consultá-los em uma linguagem SQL, por exemplo), um computador que
tenha bancos de conhecimentos disponíveis poderá processar
conhecimentos (*knowledge processing*), em vez de simplesmente
processar dados (*data processing*). Processar conhecimentos, aqui,
significa, portanto “fazer raciocínios” ou “fazer inferências” como
no raciocínio *C* anterior.

Para o consulente é simples usar *bancos de conhecimentos*. Para o
sistema, contudo, além dos conhecimentos armazenados na forma de
bancos de conhecimentos, também será preciso um “mecanismo inferidor”.
Trata-se de um software inteligente, também chamado motor de
inferências, específico para atuar sobre bancos de conhecimento e
gerar novas inferências que não sejam previamente conhecidas. O
poder de fazer inferências na quinta geração de computadores é
expresso em *inferências lógicas por segundo* ou *Iips* (*Iogical
inferences per second*). O objetivo, então, é atingir o intervalo de
50 a 1 bilhão de lips. Para avaliar o que isso significa, considere-se
que até recentemente os programas inteligentes disponíveis no
mercado (aqueles que fazem o computador “raciocinar” por meio de
inferências) permitiam apenas de 10 a 100 mil lips.

Interface inteligente
---------------------

Não incluímos as interfaces (interface humano-computador) em nossa
definição de computador inteligente, diretamente. Mas isso fica
implícito no conceito de inteligência da máquina. A interface
inteligente é um programa ou um conjunto de programas para servir de
ponto de contato desses computadores com seus usuários. A meta é
moldar a comunicação entre ambos, utilizando conjuntos das
linguagens humanas, livrando o usuário, assim, das linguagens
artificiais de programação e fazendo a comunicação se aproximar o mais
possível da maneira de se expressar e de pensar do usuário.

O troco dos americanos
----------------------

Refeitos do impacto provocado pelo desafio do ICOT, tanto
norte-americanos como europeus se lançaram na corrida tecnológica
pelos computadores inteligentes. Nos anos 1980-1990, cinco grandes
projetos se encontravam em pleno desenvolvimento: o projeto japonês já
mencionado,

os projetos MCC e DARPA dos Estados Unidos, o projeto ESPIRIT do
Mercado Comum Europeu e o programa ALVEY do Reino Unido. Na América, o
projeto MCC é apoiado por um grupo de empresas que formam a
Microelectronic and Computer Technology Corporation — MCC. A IBM não é
membro da MCC.

Já o projeto DARPA (Defense Advanced Research Project Agency) pesquisa
os computadores inteligentes para fins militares. O projeto ESPIRIT
dos países europeus apoia as pesquisas em desenvolvimento por meio de
um consórcio entre indústrias e universidades. Cinquenta por cento dos
custos das pesquisas são pagos com fundos no Mercado Comum Europeu. De
maneira semelhante, a Inglaterra financia a produção dos computadores
inteligentes. Para os ingleses, sobretudo, a importância desses
computadores está resumida no pensamento de Clive Sinclair, industrial
e cientista: Computadores inteligentes ou “a quinta geração é o
maior campo de batalha deste século. Se perdermos, já estaremos fora
do jogo”.

![](media/image3.png){width="0.8965430883639545in"
height="0.37385389326334206in"}

COMPUTADOIREXS VIVOS OU DE DNA
==============================

### Computadores são

**“entes matemáticos” encarnáveis**

Afirmamos em página anterior que os computadores, fundamentalmente,
são “entes matemáticos”. Computadores são “entes abstratos” ou ainda
“modelos conceituais” chamados *máquinas computadoras abstratas*,
antes mesmo de encarnarem uma possível roupagem material. Agora
precisamos retomar essa ideia central tendo em vista poder introduzir,
neste ponto, outras classes de

computadores que completam a nossa visão ampla sobre eles. A grande
implicação em tomar os computadores como “entes abstratos” (objetos
matemáticos) está na conclusão a que se chega, aquela de que ele —
em sua “forma metálica” ou encarnado na forma de materiais sólidos
como o conhecemos — passa a ser mera circunstância. O computador saiu
dos modelos conceituais abstratos e se encarnou em uma forma metálica,
que, entretanto, poderia ter sido qualquer outra forma concebível e
compatível com a estrutura conceitual dos modelos *de máquinas com-
putadoras abstratas*. É assim que os computadores são tratados —
hoje como ontem (1936) — na computação conceitual da *teoria da
computação*, um dos ramos mais abstratos da informática.

Esses “entes matemáticos” vão se encarnar de forma completamente
diferente do que foi visto até aqui. Neste capítulo, como também no
seguinte, vamos nos dedicar a duas classes revolucionárias de
computadores que dominarão o século XXI. São capítulos para fugirmos
dos computadores comuns até aqui tratados, chamados computadores de
modelo *Von Neumann* (o húngaro-americano que, ao lado de Alan
Turing, é um dos pais dos

computadores atuais, pai da teoria dos jogos, mas também um dos
criadores da bomba atômica). O estilo Von Neumann dos computadores
atuais que está com seus dias contados consiste no modelo serial: o
computador pega cada uma de suas instruções, sequencialmente, e exe-
cuta uma por uma de cada vez. A revolução de que falo é a dos: I)
computadores (não seriais; e não mais na roupagem metálica) na forma
viva de DNA — os computadores de DNA; e também dos II) computadores
possibilitados pela intrigante área da *teoria quântica* — os
computadores quânticos.

**Computadores não metálicos: Máquina de Turing**

*Máquina de Turing* é o mais famoso exemplo de computador puramente
conceitual (*máquina computadora abstrata*), criada pelo matemático
britânico Alan Turing (1936) quando ainda nem se pensava nos
computadores na *forma* como eles existem atualmente. Foi o primeiro
computador da humanidade; onde o termo computador

se refere não a um objeto — mas a seres humanos envolvidos em
computação. Há um outro computador conceitual irmão da *máquina de
Turing*, aliás, coincidentemente também criado no mesmo ano de 1936 —
que é a *máquina de Post* — porém, nem Turing nem Post nunca
especificaram quais materiais deveriam ser usados para construir
essas máquinas.

O lado fantástico desses modelos abstratos e universais reside
justamente aqui. Eles são máquinas (porque envolvem uma computação),
mas como são máquinas abstratas (ou que não têm especificidades de
fios elétricos, transistores ou portões lógicos etc.), em qualquer
momento da tecnologia dos computadores elas podem ser requisitadas
para servir de referência na hora da realização de algum computador
real (“de carne e osso”). Ou seja: a máquina de Turing pode ser
construída com algum material apropriado mas — não o sendo necessa-
riamente — ela é *uma máquina virtual* e não uma *máquina real*.
Qualquer implementação real de computador tem de levar em conta essa
máquina virtual. Tem de haver uma compatibilidade entre a máquina
virtual e a máquina real (independentemente de suas materialidades).

É como se a *máquina virtual* fosse a alma; enquanto a *máquina real*
seria o corpo, a depender das “materialidades” a serem utilizadas.

Como funciona então a máquina de Turing? Na verdade, Turing e Post
imaginaram tais máquinas como uma pessoa que computa por meio de uma
folha de papel infinitamente longa, um lápis e um simples manual de
instruções. Esse computador não metálico — imaginado como pessoa —
leria incansavelmente um símbolo, o modificaria e depois passaria
para o símbolo seguinte, de acordo com regras programadas, e
continuaria agindo assim até que nenhuma regra mais se aplicasse.
Vamos então concluir sobre máquina de Turing dizendo:

MÁQUINA DE TURING: este dispositivo mental opera sobre uma fita
codificadora de informações que possui símbolos, como “*a*” e “*b*”.
Uma unidade de controle com capacidade de ler/gravar processa essa
fita, uma posição de símbolo de cada vez, de acordo com instruções
fornecidas por regras de transição (regras assim: S0, a —&gt; S1, b,
L), regras essas que registram o próprio estado interno da unidade de
controle. Desse modo, a regra de transição nesse exemplo

está a determinar que: se o estado da unidade de controle é 0 (pois
o lado esquerdo da regra fala em S0), e o símbolo lido é “*a*” (também
no lado esquerdo), então a unidade de controle deve mudar seu estado
para 1 (pois o lado direito da regra fala em S1), mudar também o
símbolo para “*b*” (no lado direito da regra), e avançar uma posição
para a esquerda (L, na regra = left = esquerda).

A informática mundial neste começo de milênio passa por reviravoltas,
justamente pelo fato de que esse comportamento da máquina de Turing
foi encontrado em outras paragens bem distantes dos objetos metálicos.
Você sabe onde? Foi encontrado nas moléculas biológicas ou de DNA. É a
computação por moléculas, mediante a qual os cientistas já estão
criando máquinas minúsculas capazes de falar diretamente com células
vivas.

Computadores vivos: Máquina de DNA
----------------------------------

Foi uma descoberta inesperada, a descoberta das máquinas moleculares
naturais (*máquina de DNA* ou *computador vivo*) que processam
informações de maneira

semelhante à maquina de Turing, mas cujo desempenho poderá superar o
dos computadores de silício. Isto em problemas de difícil computação,
por exemplo, de natureza matemática. Foi mostrado por Leonard
Adelman (da University of Southern California) que mesmo um mi-
núsculo tubo de ensaio de DNA pode resolver problemas que deixariam um
supercomputador engasgado.

Moléculas de DNA são o material ideal para um computador molecular
onde a informação é codificada. No caso dos computadores de silício
(como visto em seções anteriores) essa codificação é feita em código
binário (por exemplo: 0001110010...). Mas, no caso do DNA, o código é
escrito em quatro símbolos: A, T, C, e G que correspondem aos quatro
ácidos nucléicos que o compõem. O código do DNA consistiria em três
bilhões de letras que apareceriam na forma de um fio de letras sem
sentido, a olho nu:

ATTTCCCCGAATCGGTCTGTGAGAGCGCGAAAAAA...

Usando uma série de processos químicos complexos

-   como enzimas de restrição para cortar DNA — e a reação em cadeia
    polimerase para reproduzir sequências de

DNA é possível reproduzir, passo a passo, todas as operações de uma
máquina de Turing. Qual o significado disso? Significa que podem ser
vistas, estudadas, testadas e desenvolvida industrialmente, máquinas
em escala molecular dentro de células — a máquina de DNA.

Vantagens dos computadores de DNA
---------------------------------

O computador de DNA, assim como o computador de chip de silício, são
ambos digitais. Ambos se baseiam em dado/informação;

Moléculas de DNA são eficientes e compactas, constituindo apenas
0,3% do volume do núcleo da célula;

O DNA acumula mais de 100 trilhões de vezes toda aquela informação
armazenada nos atuais e sofisticados dispositivos de computação;

“Meio quilo de moléculas de DNA (suspensas em cerca de mil litros de
líquido, o que ocuparia cerca de um metro cúbico) poderia armazenar
mais memória que todos os computadores já fabricados. Teria cem
trilhões de vezes a capacidade do cérebro humano”;

Computadores de silício calculam um número por vez (estilo Von
Neumann) e também geram grande quantidade de calor. Já os
computadores de DNA — embora lentos — podem calcular *simultaneamente*
um número astronômico de moléculas e são *bilhões de vezes* mais
eficientes, do ponto de vista energético;

Um número astronômico de moléculas de DNA armazenadas em um tubo de
ensaio típico (cerca de 1010) pode estar efetuando cálculos ao mesmo
tempo (simultaneamente);

Uma das vantagens principais desses computadores vem de seu potencial
de funcionarem em *ambientes bioquímicos*. Até mesmo dentro de um
organismo vivo;

Computadores de moléculas vivas já tiveram a viabilidade
provada/testada e podem se revelar valiosa ferramenta médica. Um
computador biomolecular poderá agir como um “médico” autônomo dentro
de uma célula, por exemplo. Já que seu ambiente de atuação é o
ambiente bioquímico, ele poderá perceber sinais do ambiente indi-
cando certa doença, processá-los usando seu conhecimento médico
pré-programado e gerar um sinal ou um remédio terapêutico (como a
*saída/output* do sistema);

Desvantagem: Moléculas de DNA acabam por se degradar. Não podem ser
armazenadas imensas quantidades de dados por longos períodos. A
memória tem de ser finalmente transferida para computadores
convencionais.

Computadores de DNA: prova pela equivalência das máquinas
---------------------------------------------------------

Nesta nova computação, ao lado de Leonard Adelman já referido, vêm se
juntar os papas Ehud Shapiro (de Rehovot, Israel) e Yaakov Benenson
(hoje, em Harvard). Eles descobriram que, à medida que o
funcionamento das minúsculas máquinas da Natureza era revelado,
semelhanças impressionantes com a Máquina Conceitual de Turing
também emergiam. Tanto a *Máquina de Turing* quanto a Máquina de
*Shapiro-Benenson*, aqui abordada, são sistemas computadores: I)
armazenam informações em sequências de símbolos (embora símbolos
diferentes); II) processam essas informações; e III) modificam ou
acrescentam símbolos de acordo com regras fixadas. Estava provada,
assim, a equivalência com a Máquina Universal de Turing. Ou melhor:

estava provada a existência de uma Máquina de Turing de DNA (um
computador de DNA).

A máquina de DNA, portanto, fala a linguagem ou armazena informação
na linguagem das moléculas (ou das células vivas) e consiste, como
dissemos, na linguagem de uma série de quatro ácidos nucleicos
dispostos como AACCGTTCCC. Mas é possível estabelecer uma equiva-
lência entre a linguagem da máquina de DNA e a linguagem da máquina
de Turing. Assim: pode-se estabelecer que ATTCG =1, TCGGA = O, GATTC =
1. É uma equivalência nas linguagens de uma máquina e de outra.

Assim como fizemos para a máquina de Turing, queremos agora fazer o
enunciado da máquina de DNA. Antes, porém, será preciso identificar o
hardware, o software e o estado da máquina, em termos de ambiente
bioquímico. Note-se a nova linguagem dessa computação:

*HARDWARE*: A enzima *Fokl* sempre reconhece

— em um local próprio de reconhecimento — a sequência de
nucleotídeos GGATG e remove uma fita dupla de DNA até às posições de
nucleotídeos 9 e 13, por exemplo, para depois do local de
reconhecimento por *Fokl*.

*SOFTWARE*: As regras de transição são codificadas em oito moléculas
de DNA de fita dupla curtas, contendo o local de reconhecimento
*Fokl*, seguido de nucleotídeos espaçadores e de uma extremidade
pegajosa de fita única, que se unirá à sua sequência complementar em
uma molécula de entrada.

*ESTADO DA MÁQUINA E SíMBOLOS*:

Combinações dos símbolos *a*, *b* ou de término t e símbolos de
estados de máquina (**1** e **0**) são representados por sequências
de quatro nucleotídeos. A depender de como a sequência de cinco
nucleotídeos TGGCT é clivada em quatro nucleotídeos, por exemplo,
ela então denotará o símbolo *a* e um dos estados 1 ou 0.

A ideia central nessa máquina de DNA consiste, assim, em empregar uma
molécula de DNA de fita dupla para representar a sequência de
entrada (a ser computada); outras quatro mais curtas para representar
as regras de transição do autômato ou *software*; e duas enzimas
manipuladoras de DNA naturais — *Fokl* e ligase — como *hardware*. A
combinação formada por este hardware-software constitui a nova
encarnação da Máquina de Turing, agora na forma

de computadores vivos de DNA, definidos por seus criadores Shapiro e
Benenson como:

*MÁQUINA DE DNA*: uma organela presente em células, de nome RIBOSSOMO,
lê informações codificadas em transcrições de genes conhecidas como
mensageiros RNAs (ou mRNAs) e as traduz em sequências de aminoácidos
para formar proteínas. O alfabeto simbólico de mRNA é feito de
trincas de nucleotídeos (ou códons), cada um correspondendo a um
aminoácido específico. À medida que o ribossomo processa o filamento
de mRNA, um códon por vez, moléculas auxiliares chamadas RNAs de
transferência (ou tRNAS) fornecem o aminoácido correto. O tRNA
confirma a correspondência do códon, depois

libera o aminoácido para se juntar à cadeia crescente.

Computadores de DNA: prova pela realização da máquina
-----------------------------------------------------

Funciona esse computador feito de DNA, perguntaria você? Como se dá
então a operação dessa máquina? A computação ocorre quando todo o
complexo hardware-

-software reconhece uma combinação complementar de:

estado da *máquina-símbolo* — na molécula de entrada. As moléculas
unem-se para formar um complexo de entrada no hardware-software.
Depois *Fok*l cliva a molécula de entrada para expor o próximo
símbolo. Apresentamos aqui apenas dois exemplos de funcionamento
concreto, funcionamento este em problemas difíceis ou cientifica-
mente desafiantes:

PROVA 1: *Funcionamento em Medicina*

Foi testado um autômato biológico, formado de DNA e proteínas, capaz
de fazer um diagnóstico médico, trabalho feito pelos próprios
criadores da máquina de DNA. No caso, a máquina, com sucesso, foi
capaz de diagnosticar — em um tubo de ensaio — sintomas moleculares
de certos tipos de câncer e “tratar” a doença com a liberação de uma
molécula terapêutica. Sucesso, evidentemente, dependente do conjunto
de enzimas que foi possível utilizar.

PROVA 2: *Funcionamento no clássico problema do caixeiro-viajante*

O problema do caixeiro-viajante é clássico por seu grau de dificuldade
em informática, muito embora seu enunciado possa ser enganosamente
simples. O objetivo no problema é

descobrir a rota mais curta entre cidades ligadas por avião, passando
apenas uma vez em cada cidade. Em outras palavras: calcular o
caminho mais curto que um caixeiro-viajante deve percorrer para ligar
*N* cidades, de tal modo que visite, uma só vez, cada cidade. Note-se
que esse problema (ou suas versões) pode se tornar extremamente
difícil à medida que o valor de *N* aumenta.

Foi esse o problema levado para ser resolvido no ambiente puramente
bioquímico dos computadores vivos. Ao criar moléculas de DNA para
representar simbolicamente todas as cidades e todos os voos e,
depois, combinar trilhões delas em tubo de ensaio, o computador de
DNA se aproveitou das afinidades de emparelhamento das moléculas para
obter resposta para o problema. O computador de DNA resolveu o
problema em uma semana; enquanto que um computador serial ou comum
(padrão Von Newmann) teria levado vários anos para fazer o mesmo.

![](media/image3.png){width="0.8965288713910761in"
height="0.37385389326334206in"}

COMPUTADXORES QUÂNTICOS
=======================

Interesse pelo estranho
-----------------------

Computadores quânticos já estão sendo chamados de computadores
definitivos. São computadores que já existem nos melhores
laboratórios de informática do mundo, como complexo
*hardware-software-dado*. Já tiveram suas existências provadas pelo
esforço de numerosos grupos de cientistas tais como os físicos que
viram informatas e os informatas que se transformam em físicos, e
mais recentemente, pelo esforço de consórcios de pesquisa a
envolverem empresas e universidades gigantes.

São computadores, portanto, ainda em laboratório e que só estarão no
mercado, em escala industrial, pra depois do ano 2050, conforme as
previsões.

O que tanto atrai o mundo dos negócios e o mundo científico, em volta
da computação quântica? Quais suas propriedades originadas do
esquisito mundo quântico? Em que esses estranhos computadores se
diferenciam daqueles do padrão Von Neumann de hoje? Quais os pro-
gressos dos computadores quânticos, ainda tão desconhecidos entre nós?
Lançamos luz sobre algumas dessas questões, apenas.

Computadores subatômicos
------------------------

A esquisitice desses computadores decorre do mundo estranho em que
devem atuar: o mundo subatômico. Ao tratarmos dos computadores de DNA
também consideramos seus ambientes, os “ambientes bioquímicos”. Pois
bem. Os ambientes bioquímicos, anteriormente vistos, são bem
comportados em relação ao mundo quântico. No mal comportado ambiente
quântico temos que: I) o

total da realidade física contém muitos “universos paralelos”; II)
universos paralelos significam que, em cada universo, as partículas
interagem umas com as outras, da mesma forma que fazem no universo
tangível, visto a olho nu; III) domina o efeito *interferência* que é
o efeito de uma partícula de um universo sobre sua contrapartida em
outro universo; IV) um elétron pode estar em dois lugares ao mesmo
tempo; e V) o núcleo de um átomo pode estar girando tanto no sentido
horário quanto no anti-horário, ao mesmo tempo.

Computadores quânticos são aqueles que exploram esses paradoxos
contidos nas propriedades da matéria e da natureza, ao terem de atuar
nesse mundo subatômico. São guiados pelas regras da incerteza do
*quantum*, do qual trata a teoria quântica.

Imagine que você tenha de atravessar o Central Park de Nova York
caminhando. Esse caminhar, para a teoria quântica, significa calcular
sua chance de chegar ao outro lado do parque. E calcular essa chance
significa que você deve primeiro somar a contribuição de todos os
caminhos possíveis de um ponto até o ponto seguinte no Central
Park — inclusive os caminhos que passam por Marte,

Júpiter e, até mesmo, os que passam pela galáxia de Andrômeda
chegando aos quasares. Quando todas essas incríveis viagens aos
rincões exteriores do universo estiverem somadas, você obterá a
probabilidade de cruzar o Central Park.

Como o ambiente quântico (a teoria) desses computadores *soma* todos
os caminhos entre dois pontos, inclusive os que passam pelas
estrelas distantes, disto segue um conceito simplificado de computador
quântico:

*COMPUTADOR QUÂNTICO*: É uma gigantesca máquina de somar, somando um
número infinito de trajetórias em um piscar de olhos e levando em
conta processos quânticos, como a INTERFERÊNCIA e a colaboração
entre UNIVERSOS PARALELOS.

Qubits em vez de bits
---------------------

Os computadores comuns (ou a máquina de Turing que lê/grava em fita)
possuem *bits*, os quais sempre codificam o estado de algum sistema
físico (um interruptor, por exemplo). Um bit é 1 ou um bit é 0. Não
há

intermediário. Computadores quânticos, em vez de bit, possuem *qubit*
(de *quantum bit*). Como o computador tem de operar no nível do átomo,
um qubit representa os estados desse átomo, mas com estranhas
propriedades decorrentes do comportamento dos átomos. Suponha que os
átomos sejam ordenados e estejam girando — como piões — arranjados de
tal modo que o eixo do giro possa apontar ora para “cima”, ora para
“baixo”. Aparece então a figura do *estado do giro do átomo*, estado
esse chamado de *spin*. Estado de giro para baixo significa *spin*

= 0 (eixo do pião para baixo); enquanto giro para cima significa
*spin* = 1. O problema, porém, é que no computador quântico, o
*spin* de um átomo não é bem definido, podendo ele ser 1, ou O, ou uma
coerente superposição desses dois estados. Ou seja: o átomo, no caso
de coerente superposição, está em ambos os estados 1 e 0 ao mesmo
tempo. Isto significa que o computador quântico tem de levar em conta
a soma de um *spin* para cima e de um *spin* para baixo.

O poder de fogo desses computadores decorre justamente do fato de o
*qubit* poder existir ao mesmo tempo entre 1 e 0, o que significa que
computadores quânticos

podem executar operações infinitamente mais complicadas do que as
efetuadas no padrão Von Neumann de computador. Por exemplo: considere
um registro composto de somente 3 bits (nos computadores normais). Com
3 bits, vão existir — no máximo — 8 possibilidades de armazenagem de
números diferentes, sendo eles: 000, 001, 010, 011, 100, 101, 110,
111. Porém, o registro desse computador normal só vai poder armazenar
apenas *um* desses números de cada vez. No computador quântico
trabalhando com 3 *qubits* em *coerente superposição*, todos os 8
números poderão ser armazenados de uma só vez. E se nós continuarmos a
acrescentar *qubits* neste registro quântico, aumentaremos a
capacidade de armazenagem desse computador exponencialmente. Ou
seja: com 3 qubits serão possíveis armazenagens para 8 números (ou
2³) diferentes de uma só vez; com 4 qubits serão armazenados 16
números (ou 2⁴); com 5 qubits serão armazenados 32 números (ou 2⁵); e
assim por diante. Generalizando, tem-se que: L qubits

podem armazenar 2L números de uma vez só.

Hardware-software quânticos
---------------------------

O que dizer agora sobre o hardware e o software quânticos — animais
completamente diferentes do que conhecemos até aqui? É complicado
fazer a diferenciação em relação aos computadores seriais. Mas vamos
rapidamente tentar essa diferenciação, antes introduzindo: I) um
*Princípio* da computação quântica; e II) um exemplo de processamento.
Ao final, espera-se que tanto o *hard* como o *soft* quânticos sejam
desnudados:

*PRINCÍPIO QUÂNTICO*: a computação quântica introduz
imprevisibilidades (probabilidades). Mas também garante um único e bem
definido resultado (output). Mesmo que em estágios intermediários —
universos intermediários — possam ocorrer resultados diferentes (não
únicos) dos experimentos, ao computar-se o resultado de todos os
universos ele será um só. PROCESSAMENTO: dado um “átomo de luz” — ou
fóton. Pede-se computar o resultado da ação de se projetar esse fóton
sobre barreiras de espelhos ou interferômetros. Fazer o
processamento usando tanto um espelho normal como um espelho
semitransparente (dois tipos de interferômetros).

A Figura 1 que segue mostra o resultado (o output) da computação do
comportamento deste átomo de luz (ou *fóton*, indicado pela seta),
empregando-se, inicialmente, espelhos semitransparentes (aqui,
indicados pelas barras cinzentas). Em 50% dos estágios intermediários
o *fóton* atinge o espelho e reflete para fora. Mas nos outros 50% o
*fóton* atravessa o espelho, como se não houvesse nada ali. Ou seja: o
output do processamento está a diferir somente no caminho tomado
pelo *fóton*.

![](media/image6.png){width="2.956597769028871in" height="1.78in"}

Mas em 100% dos estágios ou na computação final dos universos (como
ilustrado na figura que segue), o resultado ou output é único, com o
fóton resvalando sobre

o espelho comum ou *interferômetro* (indicado pela barra preta), como
ilustra a Figura 2.

![](media/image7.png){width="3.668416447944007in"
height="0.8733333333333333in"}

Agora, com essa computação exemplificada, as ideias de hardware,
software e output quânticos ficam muito mais palatáveis:

*HARDWARE QUÂNTICO*: é formado pelo *fóton*, no exemplo; e os
interferômetros (espelho normal e espelho semitransparente) usados
para medir fenômenos de interferências de partículas subatômicas.
*SOFTWARE QUÂNTICO*: é formado pela programação da configuração dos
espelhos, com certa geometria e de modo a projetar um único fóton
sobre

o interferômetro/espelho.

*OUTPUT*: é o resultado da computação, determinando assim a direção
seguida pelo fóton.

Vantagens dos computadores quânticos
------------------------------------

-   Computador e computação quântica, ao trabalharem no nível de
    elétrons, moléculas, partículas e átomos não apenas viabilizam as
    tecnologias de *miniaturização* dos computadores já existentes, como
    muita gente pensa;

-   Como também estão vindo para imprimir *velocidade* aos
    computadores atuais;

-   Reproduzir ambientes cuja replicação é *intratável*

(*hard problems*), em nossos computadores clássicos;

-   *Fatorar* grandes números, problema infernalmente difícil em
    informática. Em pequenos números, a fatoração é trivial como
    fazíamos na escola primária para fatorar o número 12, achando
    números menores, tais que: 12 = 2 x 2 x 3; por exemplo, foram
    necessários oito (8) meses para uma tropa de 1.600 computadores
    normais do mundo todo — conectados via internet — fatorarem um
    número de 129 algarismos. Essa mesma tropa de computadores levaria
    séculos para *fatorar* um número de 250 algarismos. Se for escrever
    no papel todo esse raciocínio (os passos da fatoração), ele
    exigiria nada menos de 10500 linhas escritas. Sabe você a que
    correspondem tantas

linhas escritas? Correspondem a mais do que todos os átomos existentes
na face da Terra. Não há átomos suficientes (pois eles ao todo são
1080) no Universo visível para nos permitir escrever os passos
necessários para fatorar um número de 250 algarismos;

-   Computadores quânticos fazem fatoração em *tempo polinomial*. Isso
    não significa que possam calcular instantaneamente. Eles também
    levam tempo para executar cálculos. Mas processam esses problemas
    difíceis no chamado *tempo polinomial*. Isto é: a quantidade de
    tempo “não aumenta exponencialmente”, mas apenas como uma potência,
    o que já é uma imensa vantagem sobre os nossos computadores de hoje;

-   O *algoritmo de Shor* é a mais espetacular descoberta quântica para
    a fatoração de números. Foi feita em 1994 por Peter Shor (no Bell
    Laboratories, New Jersey), usando hardware quântico simples, embora
    não universal;

-   O *algoritmo de Grover* é outra descoberta para a busca rápida em
    longas listas de elementos;

-   A *criptografia* é o campo de aplicação dessa fatoração por
    computador onde se encontram o Sherlock-Holmes (o desvendador de
    mistérios) e os computadores quânticos.

Protótipos de criptografia quântica já foram desenvolvidos. O primeiro
deles ainda em 1989. (*Scientific American*, out, 1992, p. 50).

Um marco na criptografia quântica foi alcançado em 1996 quando
cientistas enviaram uma mensagem secreta por uma fibra óptica de 22,7
km de comprimento. Essa mensagem foi transportada por luz
infravermelha e enviada de Nyon, na Suíça, para Genebra, mostrando
que um princípio abstrato da teoria quântica podia ter aplicações
práticas no mundo real.

A explosão da capacidade dos computadores quânticos levará a
decifrar a maioria das mensagens cifradas, o que é só uma questão de
tempo.

![](media/image3.png){width="0.8965288713910761in"
height="0.37385389326334206in"}

COMPUTADORES NESTA VIRADA DE SÉCULO
===================================

**“Computadores espirituais”**

Vamos, nesta seção final, desenhar o próximo cenário para os
computadores e a informática nesta virada de século. E vamos fazê-lo
com base não em ficções — que são frequentemente desgastantes. Estamos
falando com base na ciência e na experiência de Ray Kurzwell, um
cientista e, ao mesmo tempo, empreendedor, autor do *best-seller*
norte-americano *A idade das máquinas espirituais* (*The age of
spiritual machines*, Penguin Books, USA, 1999). O título

do livro, como se vê, já é suficiente para trazer arrepios ao nosso(a)
leitor(a).

Mas vamos falar claro, desde o início. A *inteligência dos
computadores, hoje, já suplanta a inteligência dos humanos*. É a
chegada — acredite o (a) leitor(a) — da idade dos *computadores
espirituais*! É bem sabido que essa afirmação se torna verdadeira para
um leque ainda um tanto restrito de tarefas humanas suplantadas. Por
exemplo: I) jogo de xadrez; II) certos diagnósticos médicos; III)
compra e venda em estoques; IV) cálculos matemáticos; e V)
direcionamentos de mísseis teleguiados. Mas também é verdadeiro que,
mesmo nessas tarefas, a inteligência humana continua sendo muito mais
flexível, muito mais rapidamente responsiva e graciosa. Computadores
continuam impossibilitados, por exemplo, de descrever objetos
espalhados sobre uma mesa de cozinha; escrever a sinopse de um filme;
atar os cadarços de um sapato; reconhecer uma situação de humor;
dizer a diferença entre um cachorro e um gato (embora essa diferença
esteja hoje sendo viabilizada por *redes neuronais* — simulações
computacionais dos neurônios humanos); ou realizar outras tarefas
sutis nas quais excede a inteligência do criador humano.

Uma razão para a disparidade existente entre a inteligência de
computadores-robôs e a inteligência humana está no fato de que o nosso
mais avançado supercomputador (o *Touch-stone Delta*, por exemplo,
ou outro já operando na casa dos *teraflops* — um trilhão de
operações por segundo) continua ainda hoje sendo cerca de um milhão de
vezes mais simples do que o cérebro humano. A situação, porém, é que
essa disparidade não continuará a mesma, logo no começo já do presente
século, se atentamente se considerar a curva da aceleração
tecnológica. Considere o seguinte: os computadores dobraram de ve-
locidade a cada três anos, isso, no começo do século XX. Dobraram de
velocidade em dois anos entre 1950 e 1960; e, presentemente, estão a
dobrar de velocidade em cada doze meses. Essa tendência vai continuar
nessa mesma progressão, com os computadores atingindo a capacidade de
memória e a velocidade de computação do cérebro humano por volta do
ano 2020, conforme nos garante Ray Kurzwell.

Inteligência via engenharia reserva
-----------------------------------

Atingindo a complexidade básica e a capacidade do cérebro humano,
contudo, não vai ainda resultar em os computadores, automaticamente,
se equipararem à flexibilidade da inteligência humana. Será
igualmente importante criar a “organização” e os “conteúdos” desses
recursos a levarem a esta equiparação. Ou seja: os softwares de
inteligência, para além de seu hardware. Uma abordagem para emular o
software do nosso cérebro — a sua “organização” e “conteúdos”,
capazes de fazer emergir a inteligência, a partir dos neurônios —
será por meio da *engenharia reversa* — que, por definição, inicia-se
com o desmonte de algo para compreendê-lo ao fazer o caminho de volta
de sua montagem.

Em tal caso, a engenharia reversa atuará escaneando o cérebro humano
todo (o que será conseguido logo no começo deste século) e,
essencialmente, copiando o desenho dos circuitos neuronais em um
computador neuronal (especialmente concebido, com suficiente
capacidade) para simular o massivo número de neurônios humanos — um
velho sonho, do começo da Inteligência Artificial.

Um conjunto fabuloso de *cenários* possíveis nasce, então, quando o
computador atingir o nível da inteligência humana. Seremos então
capazes de desenvolver e treinar sistemas, de modo a combinar redes
neuronais artificiais — massivamente paralelas — com outros para-
digmas computacionais para: I) entender linguagens humanas e modelar
conhecimentos; e, inclusive, II) modelar a habilidade de ler e
entender documentos escritos.

Embora a habilidade dos computadores de hoje de extrair e aprender
conhecimentos, a partir de documentos escritos em *linguagem
natural* (humana), ainda seja bem limitada, suas habilidades nesse
domínio vêm melhorando rapidamente. Computadores serão capazes de
ler por si só, entender e modelar o que lerem, já pela segunda
década do século XXI. Neste ponto, então, poderemos fazer com que
nossos computadores leiam toda a literatura do mundo: livros, revistas
comuns, revistas científicas e outros materiais disponíveis. Por fim,
as máquinas coletarão ou adquirirão conhecimentos por conta própria,
se aventurando no mundo físico, extraindo este conhecimento de um
espectro muito amplo de *mídia* e de serviços de informação e,
sobretudo, compartilhando-o

com outro computador (compartilhamento, aliás, que os computadores já
podem fazer mais facilmente do que os humanos, seus criadores). Os
computadores estarão então “falando” entre si a respeito de
conhecimentos, por meio deste compartilhamento.

Cenários dos computadores no século XXI
---------------------------------------

Uma vez tendo o computador atingido o nível da inteligência humana,
ele a superará necessariamente. Considere o seguinte: desde sua
introdução, os computadores já excederam a destreza mental dos humanos
em suas habilidades de: I) relembrar as coisas; e II) processar
informações. Um computador pode relembrar bilhões ou mesmo trilhões
de fatos com perfeição, enquanto nós, humanos, mal conseguimos
relembrar um punhado de números de telefones. Um computador pode
rapidamente pesquisar um *banco de dados* contendo bilhões de
registros, em fração de segundos. Prontamente, ele poderá compartilhar
(com outros computadores e humanos) seus *bancos de conhecimentos*. A
combinação, em um só

computador, de uma inteligência em nível humano com sua inerente
superioridade computacional em velocidade, acuidade, compartilhamento
de sua memória, só poderá resultar em um feito formidável.

Neurônios de mamíferos — como os nossos — são criações maravilhosas,
mas nós, humanos, não temos de criá-los da mesma maneira que a
*evolução* os criou. Mesmo porque a maior parte da complexidade
intrínseca desses neurônios está em dever apoiar seus próprios pro-
cessos de vida neuronal; e não em suas habilidades de manipulação de
informação. Além do mais, neurônios são extremamente vagarosos.

Para você imaginar o quanto os neurônios são comparativamente
lerdos, considere o caso do esforço de aprendizagem, empreendido pelos
humanos. O cientista Thomas Bellcore, por exemplo, fez uma conta
interessante para descobrir que o nosso cérebro não sabe lá tantas
coisas assim. Ele calculou que uma pessoa comum aprende algo a uma
taxa de dois bits por segundo. Estendendo esse primeiro cálculo, um
dos pais da Inteligência Artificial — Marvin Minsky (autor de *A
sociedade da mente*, Francisco Alves, 1985) — conclui seu próprio
raciocínio

a respeito, afirmando: “Se fosse possível manter essa taxa por 12
horas diárias, durante cem anos (100 anos), o total poderia ser cerca
de *três bilhões de bits* — menos do que podemos armazenar num CD
normal de cinco polegadas”. (*Scientific American*, out, 1994).

Mas não fique triste, não pelo que deixou de aprender, por conta da
lerdeza dos neurônios! A compensação que nos foi dada é simplesmente
genial: “Aprender é a única coisa da qual a mente nunca se cansa,
nunca tem medo e nunca se arrepende” (Leornardo da Vinci, 1452-

-1519).

Já os circuitos eletrônicos são, no mínimo, um milhão de vezes mais
rápidos. Uma vez tendo o computador atingido o nível humano, na
habilidade de entender conceitos abstratos, reconhecer padrões e
outros atributos da inteligência humana, ele será capaz de aplicar
essa sua habilidade a de *bancos de conhecimentos*, formados tanto
por conhecimentos adquiridos por humanos quanto por conhecimentos
adquiridos por máquina.

A primeira reação comum, em relação a essa proposição de que os
computadores irão, seriamente, competir com a inteligência humana,
consiste em querer afastar

essa expectativa, baseado, sobretudo, no exame da capacidade dos
computadores do presente momento. Ao interagirmos com nossos
computadores pessoais, a inteligência deles parece ainda limitada e
férrea. É difícil, nesse quadro, imaginar um computador pessoal com
senso de humor, sustentando alguma opinião própria, ou exibindo
quaisquer das qualidades do pensamento humano.

Mas lembre-se de que o estado da arte da tecnologia computacional pode
ser qualquer coisa que se possa imaginar, exceto estático.
Capacidades computacionais que estão emergindo hoje eram consideradas
impossíveis há uma ou duas décadas. Como exemplo disto podem ser
incluídas habilidades como: I) transcrever, acuradamente, a fala
humana normal e contínua; lI) entender e inteligentemente responder
em linguagem natural; III) reconhecer *padrões* em procedimentos
médicos, como em eletrocardiogramas e em testes de sangue, onde a
precisão dos resultados já rivaliza hoje com a dos médicos; com
certeza, IV) jogar xadrez, em nível de campeonato mundial; V)
tradução de telefonemas em termos de tradução da fala em tempo real,
de um idioma para outro (já nesta

primeira década); VI) usos de software inteligente (os assistentes
pessoais inteligentes) que podem conversar e rapidamente buscar e
entender *bancos de conhecimentos* do mundo inteiro. Uma profusão
imensa de outras máquinas e sistemas estarão disponíveis, com uma
inteligência crescentemente flexível e abrangente em atuações.

Na segunda década deste século, tornar-se-á crescentemente difícil
estabelecer uma clara distinção entre capacidades humanas e
inteligência maquinal. As vantagens da inteligência computacional em
termos de velocidade, acuidade e capacidade ficarão bem mais claras.
Por outro lado, as vantagens da inteligência humana serão crescen-
temente difíceis de distinção em relação à inteligência computacional.
As destrezas dos softwares inteligentes já estão melhores do que muita
gente pensa.

Os cientistas, por exemplo, ao demonstrarem os mais recentes avanços
em *reconhecimento automático da fala* (“*speech recognition*”) e
*reconhecimento automático de escrita* (“*writing recognition*”) ficam
surpresos com o espanto da plateia de observadores ao verem o estado
da arte dos atuais softwares inteligentes. Quem via esses softwares
anos atrás lamentava o limitado vocabulário reconhecido

pelo computador, as pausas ridículas entre palavras lidas/pronunciadas
pelo computador e as muitas incorreções, no final da tarefa. A
surpresa das pessoas com os sistemas contemporâneos está,
justamente, em que os softwares inteligentes atuais já podem
reconhecer falas humanas de modo totalmente contínuas, empregando
vocabulários amplos de 60 mil palavras e com a destreza e a rapidez,
no nível de um bom taquígrafo.

Prova da inteligência dos computadores
--------------------------------------

Será preciso sempre ter em mente que o progresso na inteligência dos
computadores já começa a sobrepujar a inteligência dos humanos, para
não cairmos na decepção que teve, por exemplo, o russo Garry Kasparov,
o grande mestre campeão do xadrez mundial. Kasparov estava cheio de
confiança em 1990, e desdenhava acreditando que nunca o computador
chegaria nem de perto de derrotá-lo. Nesse ano, de fato, a habilidade
do computador em jogar xadrez foi simplesmente patética. Contudo,
logo o xadrez por computador progrediu rapidamente ganhando 45

pontos porcentuais ano a ano. Até que, em 1997, o computador Deep
Blue da IBM derrotou Kasparov.

Em muitas outras áreas de atuação, as dificuldades em levar o
computador a exibir comportamentos inteligentes são muito maiores do
que em jogar xadrez. Isto é bem verdade, de fato. Por exemplo, levar o
computador a escrever um livro! Mas pesquisadores internacionais
trabalham intensamente para dotar de mente e de habilidades, por
exemplo, os robôs movidos a softwares inteligentes (nos computadores
neles embutidos). Eles promovem anualmente a copa dos robôs — a
*Robocup*. O Brasil participou dessa copa paralela com os ITANDROIDS,
os robôs da equipe do Instituto Tecnológico de Aeronáutica (ITA). OS
cientistas estão se preparando para o grande confronto, até 2050 —
aquele em que equipes de robôs futebolistas vão superar qualquer
time humano. Isto não é bola de cristal não! É pura experimentação
científica.

Seres humanos exibem complexidade, em parte, por causa de nossas metas
internas e valores que adotamos. Valores e emoções representam
*objetivos* frequentemente até conflitantes. A complexificação dos
computadores (e de sua inteligência) é derivada, em parte, dos modelos

que conseguimos construir sobre a própria inteligência humana e é uma
complexificação que também cresce, seguindo uma curva de aceleração
geométrica. À medida que os computadores forem também dotados de
valores e emoções e atingirem um nível mais alto e também um nível
comparável de complexidade, eles também necessariamente passarão a
ter metas e objetivos, com valores e emoções implícitos embora, não
necessariamente, aqueles mesmos valores e aquelas mesmas emoções que
nós, humanos, costumamos experimentar e exibir.

Será preciso, pois, cada vez mais refletir (na Filosofia da Mente, nas
Ciências Cognitivas, na Informática, na Cyber-ética) sobre as
implicações de uma gradual e também inevitável emergência de uma
verdadeira competição dos computadores possuidores de um espectro
completo do pensamento humano, tendo em vista melhor compreender
todo um mundo novo à nossa frente.

![](media/image3.png){width="0.8965430883639545in"
height="0.37385389326334206in"}

INDICAÇÕES PARA LEITURA
=======================

Com atenção, selecionamos materiais de interesse para quem deseje
continuar essa jornada pelos computadores. Embora os interesses
envolvendo os computadores possam ser os mais variados possíveis, para
conhecimentos mais especializados você pode ir direto ao assunto ao
consultar materiais como os que seguem. São referências para
compartilhar conhecimentos ainda em nível introdutório. É importante
ressaltar isso.

### Computadores conceituais, máquina de Turing e máquina de Post

TENÓRIO, Robinson Moreira. *Computadores de papel*: Máquinas abstratas
para um ensino concreto. São Paulo: Cortez, 1991.

USPENSKY, V. A. *A máquina de Post*. Moscou: Mir, 1985.

### Computadores, organização e arquitetura

BELLAVOINE, C. *O que é um computador*. Lisboa: Clássica Editora,
1969.

VERDE, Raul. *Computadores digitais*. Lisboa: Quadrante, 1977.

### Computadores, suas linguagens e aplicações

CLARK, J. O. E. *Computadores*. Série Prisma (USP), São Paulo:
Melhoramentos, 1969.

MARSHALL, Garry. *Linguagens de programação para micros*. Rio de
Janeiro: Campus, 1986.

### Computadores inteligentes

MINSKY, Marvin. *A sociedade da mente*. Rio de Janeiro: Francisco
Alves, 1989.

PASSOS, Emmanuel Lopes. *Inteligência artificial e sistemas
especialistas ao alcance de todos*. Rio de Janeiro: LTC, 1989.

TIME-LIFE. *Inteligência artificial*. Coleção: Entenda o computador,
São Paulo: Nova Cultural, 1988.

WHITBY, Blay. *Inteligência artificial*: Um guia para iniciantes. São
Paulo: Madras, 2004.

### Computadores vivos ou de DNA

BENTLEY, Peter J. *Biologia digital*. São Paulo: Berkeley, 2002.

KAKU, Michio. *Visões do futuro:* Como a ciência revolucionará o
século 21. Rio de Janeiro: Rocco, 2001.

SHAPIRO, Ehud; Benenson, Yaakov. Computadores de DNA ganham vida. In:
*Scientific American* (Brasil), junho, 2006, pp.49-55.

### Computadores quânticos e Computadores do século XXI

DEUTSCH, David*. A essência da realidade*. Rio de Janeiro: Makron
Books, 2000.

KURZWEIL, Ray. *The age of spiritual machines*: Whencompu-

ters exceed human intelligence. England: Penguin Books, 2000.

WALDROP, M. Mitchell. Computação quântica. In:

*INFO-EXAME*, julho, 2000, pp. 91-96.

![](media/image3.png){width="0.8965430883639545in"
height="0.37385389326334206in"}

![](media/image8.png){width="0.777075678040245in"
height="1.0066666666666666in"}

SOBRE O AUTOR
=============

Agenor Martins é doutor em Ciências, com área de concentração em
*Inteligência Computacional* (ou Inteligência Artificial) pela
Universidade Federal da Paraíba, UFPB (2000). É Mestre em Informática,
quando a denominação era Engenharia de Sistemas e Computação, pela
mesma instituição (já em 1976). É bacharel em Ciências Econômicas pela
Universidade Federal do Ceará (1972). Atuou no governo estadual em
equipes de políticas públicas apoiadas pelo Banco Mundial e como
Superinten-

dente da Fundação de Pesquisa Social (CEPRO/PI), em

1979\. Tem passagem pela Reading University (Inglaterra, 1983-1985) e
pela Université de Aix Marseille III (França, 1999). Atualmente é
Professor de Tecnologia de Informação na União Educacional de Brasília
(Uneb), depois de se aposentar como Professor-adjunto de Computação da
Universidade Federal do Piauí (2002). Escreveu, pela Editora
Brasiliense, *O que é robótica* e *O que é programação*. Tem artigos
científicos publicados em nível nacional e internacional nas áreas
principais de interesse: Agentes Inteligentes; Raciocínio Baseado em
Casos (RBC); Autopoiese; Inteligência das Organizações e Inteligência
de Negócios (Business Intelligence).

![](media/image9.png){width="3.8243952318460193in"
height="0.18083223972003498in"}

ABORTO

AÇÃO CULTURAL ACUPUNTURA ADMINISTRAÇÃO ADOLESCÊNCIA AGRICULTURA
SUSTENTÁVEL ALCOOLISMO

ALIENAÇÃO ALQUIMIA ANARQUISMO ANGÚSTIA APARTAÇÃO APOCALIPSE
ARQUITETURA ARTE

ASSENTAMENTOS RURAIS ASTROLOGIA ASTRONOMIA

BELEZA BIBLIOTECA BIOÉTICA BRINQUEDO BUDISMO BUROCRACIA CAPITAL

CAPITAL FICTÍCIO CAPITAL INTERNACIONAL CAPITALISMO

CIDADANIA CIDADE

CINEMA

COMPUTADOR COMUNICAÇÃO COMUNICAÇÃO EMPRESARIAL CONTO

CONTRACEPÇÃO COOPERATIVISMO CORPOLATRIA CULTURA

CULTURA POPULAR DARWINISMO

DEFESA DO CONSUMIDOR DEFICIÊNCIA DEMOCRACIA DEPRESSÃO

DESIGN DIALÉTICA DIPLOMACIA DIREITO

DIREITOS DA PESSOA DIREITOS HUMANOS DIREITOS HUMANOS DA

MULHER DRAMATURGIA ECOLOGIA EDUCAÇÃO

EDUCAÇÃO AMBIENTAL EDUCAÇÃO FÍSICA EDUCACIONISMO EMPRESA ENFERMAGEM

ENOLOGIA

![](media/image9.png){width="3.8243952318460193in"
height="0.18083223972003498in"}

ESCOLHA PROFISSIONAL ESPORTE

ESTATÍSTICA ÉTICA

ÉTICA EM PESQUISA ETNOCENTRISMO EVOLUÇÃO DO DIREITO EXISTENCIALISMO
FAMÍLIA

FANZINE FEMINISMO FILOSOFIA

FILOSOFIA MEDIEVAL FILOSOFIA CONTEMPORÂNEA FÍSICA

FMI FOLCLORE FOME FOTOGRAFIA FUTEBOL

GASTRONOMIA GEOGRAFIA GOLPE DE ESTADO GRAFFITI GRAFOLOGIA HIEROGLIFOS
HISTÓRIA

HISTÓRIA DA CIÊNCIA HOMEOPATIA HOMOSSEXUALIDADE

IDEOLOGIA

IMAGINÁRIO IMPERIALISMO INDÚSTRIA CULTURAL INTELECTUAIS ISLAMISMO

JAZZ JORNALISMO

JORNALISMO SINDICAL JUDAÍSMO

LAZER LEITURA LESBIANISMO LIBERDADE LINGUÍSTICA

LITERATURA INFANTIL LITERATURA DE CORDEL LOUCURA

MAIS-VALIA MARKETING MARXISMO

MEDIAÇÃO DE CONFLITOS MEIO AMBIENTE

MENOR

MÉTODO PAULO FREIRE MITO

MORAL MORTE MÚSICA

MÚSICA BRASILEIRA

MÚSICA SERTANEJA NATUREZA

![](media/image9.png){width="3.8243952318460193in"
height="0.18083223972003498in"}

NAZISMO NEGRITUDE NEUROSE

NORDESTE BRASILEIRO OLIMPISMO PARTICIPAÇÃO PARTICIPAÇÃO POLÍTICA
PATRIMÔNIO CULTURAL

IMATERIAL PATRIMÔNIO HISTÓRICO PEDAGOGIA

PESSOAS DEFICIENTES PODER

PODER LOCAL POLÍTICA POLÍTICA SOCIAL

POLUIÇÃO QUÍMICA PÓS-MODERNO POSITIVISMO PRAGMATISMO PSICOLOGIA
PSICOLOGIA SOCIAL PSICOTERAPIA

PSICOTERAPIA DE FAMÍLIA PSIQUIATRIA FORENSE PUNK

QUESTÃO AGRÁRIA QUÍMICA

RACISMO REALIDADE

RECURSOS HUMANOS

RELAÇÕES INTERNACIONAIS REVOLUÇÃO

ROBÓTICA

SEGURANÇA DO TRABALHO SEMIÓTICA

SERVIÇO SOCIAL SOCIOLOGIA

SOCIOLOGIA DO ESPORTE SUBDESENVOLVIMENTO TARÔ

TAYLORISMO TEATRO TELENOVELA TEORIA TOXICOMANIA TRABALHO TRABALHO
INFANTIL TRADUÇÃO TRÂNSITO TRANSEXUALIDADE TROTSKISMO UNIVERSIDADE
URBANISMO VELHICE VEREADOR VIOLÊNCIA

VIOLÊNCIA CONTRA A MULHER

VIOLÊNCIA URBANA XADREZ
